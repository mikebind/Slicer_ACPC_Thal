import qt
import ctk
import slicer
from slicer.ScriptedLoadableModule import *
import vtk
import numpy as np
import logging

#
# ACPCTransform
#


class ACPCTransform(ScriptedLoadableModule):
    """Uses ScriptedLoadableModule base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "AC-PC Transform"
        self.parent.categories = ["Utilities", "Registration"]
        self.parent.dependencies = []
        self.parent.contributors = ["AI Assistant (Generated)", "Slicer Community"]
        self.parent.helpText = """
        This module creates a transform to align a volume to the AC-PC (Anterior Commissure - Posterior Commissure) coordinate system.
        It uses an interactive point placement widget.
        1. Select or create a Markups Fiducial node.
        2. If the node is new/empty, it will be pre-populated with "AC", "PC", "IH" unplaced points.
        3. Use the 'Place Points' widget to interactively define the positions of AC, PC, and IH in that order.
        4. Select or create an output Transform node.
        5. Click 'Apply' to generate the AC-PC alignment transform.
        The input fiducials are expected in the order: Anterior Commissure (AC), Posterior Commissure (PC), and an Interhemispheric (IH) point.
        """
        self.parent.acknowledgementText = """
        This module was generated by an AI assistant and incorporates standard Slicer widgets.
        """


#
# ACPCTransformWidget
#


class ACPCTransformWidget(ScriptedLoadableModuleWidget):
    """Uses ScriptedLoadableModuleWidget base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent=None):
        ScriptedLoadableModuleWidget.__init__(self, parent)
        self._observedMarkupsNode = None
        self._markupsObserverTags = []

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        # Parameters Area
        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Parameters"
        self.layout.addWidget(parametersCollapsibleButton)
        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        # Input Markups Fiducial Node Selector
        self.markupsSelector = slicer.qMRMLNodeComboBox()
        self.markupsSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupsSelector.selectNodeUponCreation = True
        self.markupsSelector.addEnabled = True
        self.markupsSelector.removeEnabled = True
        self.markupsSelector.renameEnabled = True
        self.markupsSelector.noneEnabled = False
        self.markupsSelector.showHidden = False
        self.markupsSelector.showChildNodeTypes = False
        self.markupsSelector.setMRMLScene(slicer.mrmlScene)
        self.markupsSelector.setToolTip(
            "Select or create the Markups Node for AC, PC, IH points."
        )
        self.markupsSelector.baseName = "ACPCSites"
        parametersFormLayout.addRow(
            "Fiducial Points (AC,PC,IH): ", self.markupsSelector
        )

        # Markups Place Widget
        self.markupsPlaceWidget = slicer.qSlicerMarkupsPlaceWidget()
        self.markupsPlaceWidget.setMRMLScene(slicer.mrmlScene)
        self.markupsPlaceWidget.buttonsVisible = True
        parametersFormLayout.addRow("Place Points:", self.markupsPlaceWidget)

        # Output Transform Node Selector
        self.outputTransformSelector = slicer.qMRMLNodeComboBox()
        self.outputTransformSelector.nodeTypes = ["vtkMRMLTransformNode"]
        self.outputTransformSelector.selectNodeUponCreation = True
        self.outputTransformSelector.addEnabled = True
        self.outputTransformSelector.removeEnabled = True
        self.outputTransformSelector.renameEnabled = True
        self.outputTransformSelector.noneEnabled = False
        self.outputTransformSelector.showHidden = False
        self.outputTransformSelector.showChildNodeTypes = False
        self.outputTransformSelector.setMRMLScene(slicer.mrmlScene)
        self.outputTransformSelector.setToolTip(
            "Select or create the output AC-PC transform node."
        )
        self.outputTransformSelector.baseName = "ACPCTransform"
        parametersFormLayout.addRow(
            "Output AC-PC Transform: ", self.outputTransformSelector
        )

        # Apply Button
        self.applyButton = qt.QPushButton("Apply")
        self.applyButton.toolTip = "Run the AC-PC transform calculation."
        self.applyButton.enabled = False
        parametersFormLayout.addRow(self.applyButton)

        # Connections
        self.markupsSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onMarkupsNodeSelected
        )
        self.markupsSelector.connect(
            "nodeAddedByUser(vtkMRMLNode*)", self.onMarkupsNodeAddedByUser
        )
        self.outputTransformSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.updateApplyButtonState
        )
        self.applyButton.connect("clicked(bool)", self.onApplyButton)

        self.layout.addStretch(1)
        self.onMarkupsNodeSelected(self.markupsSelector.currentNode())
        self.updateApplyButtonState()

    def cleanup(self):
        ScriptedLoadableModuleWidget.cleanup(self)
        self.removeMarkupObservers()

    def removeMarkupObservers(self):
        if self._observedMarkupsNode and self._markupsObserverTags:
            for tag in self._markupsObserverTags:
                try:  # Add try-except for safety during cleanup
                    self._observedMarkupsNode.RemoveObserver(tag)
                except AttributeError:  # Node might have been deleted
                    logging.debug(
                        "Could not remove observer, node might be already deleted."
                    )
        self._observedMarkupsNode = None
        self._markupsObserverTags = []

    def onMarkupsNodeAddedByUser(self, node):
        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            logging.debug(f"User added new markups node: {node.GetName()}")
            # ensureMarkupsNodeIsSetup will be called by onMarkupsNodeSelected
            # which is typically triggered after nodeAddedByUser effectively changes current node

    def onMarkupsNodeSelected(self, node):
        logging.debug(
            f"Markups node selection changed to: {node.GetName() if node else 'None'}"
        )
        self.removeMarkupObservers()

        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            self._observedMarkupsNode = node

            # Core events that should always be present
            core_event_ids = [
                slicer.vtkMRMLMarkupsNode.PointModifiedEvent,
                slicer.vtkMRMLMarkupsNode.PointAddedEvent,  # Corrected
                slicer.vtkMRMLMarkupsNode.PointRemovedEvent,  # Corrected
            ]
            for event_id in core_event_ids:
                tag = node.AddObserver(event_id, self.onMarkupPointModified)
                self._markupsObserverTags.append(tag)
                logging.debug(
                    f"Added observer for event ID {event_id} on node {node.GetName()}"
                )

            # Newer events - check for their existence by attribute name before using
            # These give more granular updates on point placement status.
            newer_event_names = [
                "PointPositionDefinedEvent",
                "PointPositionUndefinedEvent",
            ]
            for event_name_str in newer_event_names:
                if hasattr(slicer.vtkMRMLMarkupsNode, event_name_str):
                    event_id = getattr(slicer.vtkMRMLMarkupsNode, event_name_str)
                    tag = node.AddObserver(event_id, self.onMarkupPointModified)
                    self._markupsObserverTags.append(tag)
                    logging.debug(
                        f"Added observer for {event_name_str} (ID: {event_id}) on node {node.GetName()}"
                    )

            self.ensureMarkupsNodeIsSetup(node)
            self.markupsPlaceWidget.setCurrentNode(node)
        else:
            self.markupsPlaceWidget.setCurrentNode(None)

        self.updateApplyButtonState()

    def ensureMarkupsNodeIsSetup(self, markupsNode):
        if not markupsNode or not isinstance(
            markupsNode, slicer.vtkMRMLMarkupsFiducialNode
        ):
            return

        if markupsNode.GetNumberOfControlPoints() == 0:
            logging.info(
                f"Initializing markups node '{markupsNode.GetName()}' with AC, PC, IH unplaced points."
            )
            wasModified = markupsNode.StartModify()
            pointLabels = ["AC", "PC", "IH"]
            for label in pointLabels:
                markupsNode.AddNPoints(1)
                idx = markupsNode.GetNumberOfControlPoints() - 1
                markupsNode.SetNthControlPointLabel(idx, label)
            markupsNode.EndModify(wasModified)
        else:
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' not empty, skipping auto-setup."
            )

    def onMarkupPointModified(self, caller, event):
        logging.debug(
            f"Markup event (ID: {event}) received from {caller.GetName() if caller else 'UnknownCaller'}"
        )
        self.updateApplyButtonState()

    def updateApplyButtonState(self):
        markupsNode = self.markupsSelector.currentNode()
        outputNode = self.outputTransformSelector.currentNode()
        readyToApply = False

        if (
            markupsNode
            and isinstance(markupsNode, slicer.vtkMRMLMarkupsFiducialNode)
            and outputNode
            and isinstance(outputNode, slicer.vtkMRMLTransformNode)
        ):
            if markupsNode.GetNumberOfControlPoints() == 3:
                all_points_defined = True
                for i in range(3):
                    if (
                        markupsNode.GetNthControlPointPositionStatus(i)
                        == slicer.vtkMRMLMarkupsNode.PositionUndefined
                    ):
                        all_points_defined = False
                        break
                if all_points_defined:
                    readyToApply = True
        self.applyButton.enabled = readyToApply
        logging.debug(f"Apply button enabled: {readyToApply}")

    def onApplyButton(self):
        logic = ACPCTransformLogic()
        inputMarkupsNode = self.markupsSelector.currentNode()
        outputTransformNode = self.outputTransformSelector.currentNode()

        if (
            not inputMarkupsNode
            or not isinstance(inputMarkupsNode, slicer.vtkMRMLMarkupsFiducialNode)
            or inputMarkupsNode.GetNumberOfControlPoints() != 3
        ):
            slicer.util.warningDisplay(
                "Input Markups node must have exactly 3 placed points (AC, PC, IH)."
            )
            return

        all_defined = True
        for i in range(3):
            if (
                inputMarkupsNode.GetNthControlPointPositionStatus(i)
                == slicer.vtkMRMLMarkupsNode.PositionUndefined
            ):
                all_defined = False
                break
        if not all_defined:
            slicer.util.warningDisplay(
                "Not all 3 points (AC, PC, IH) have been placed yet."
            )
            return

        if not outputTransformNode:
            slicer.util.warningDisplay(
                "Please select or create an output transform node."
            )
            return

        logic.run(inputMarkupsNode, outputTransformNode)


#
# ACPCTransformLogic (Unchanged from the correctly working version)
#
class ACPCTransformLogic(ScriptedLoadableModuleLogic):
    def createACPCTransformMatrix(self, p_ac_np, p_pc_np, p_ih_np):
        logging.info("Calculating AC-PC transform matrix.")
        logging.info(f"AC: {p_ac_np}, PC: {p_pc_np}, IH: {p_ih_np}")

        origin_mcp = (p_ac_np + p_pc_np) / 2.0
        logging.info(f"Mid-Commisural Point (Origin): {origin_mcp}")

        y_axis_ras_unnormalized = p_ac_np - p_pc_np
        norm_y = np.linalg.norm(y_axis_ras_unnormalized)
        if norm_y < 1e-6:
            logging.error(
                "AC and PC points are coincident or too close. Cannot define Y axis."
            )
            slicer.util.errorDisplay(
                "AC and PC points are too close. Cannot define Anterior (Y) axis."
            )
            return None
        y_axis_ras = y_axis_ras_unnormalized / norm_y
        logging.info(f"Anterior (Y) axis (RAS): {y_axis_ras}")

        vec_pc_ac = p_ac_np - p_pc_np
        vec_pc_ih = p_ih_np - p_pc_np

        x_axis_ras_unnormalized = np.cross(vec_pc_ac, vec_pc_ih)
        norm_x = np.linalg.norm(x_axis_ras_unnormalized)
        if norm_x < 1e-6:
            logging.error(
                "Points AC, PC, IH are collinear, or PC=AC, or PC=IH. Cannot define X axis."
            )
            slicer.util.errorDisplay(
                "AC, PC, and IH points are likely collinear. Cannot define Right (X) axis."
            )
            return None
        x_axis_ras = x_axis_ras_unnormalized / norm_x
        logging.info(f"Right (X) axis (RAS): {x_axis_ras}")

        z_axis_ras_unnormalized = np.cross(x_axis_ras, y_axis_ras)
        norm_z = np.linalg.norm(z_axis_ras_unnormalized)
        if norm_z < 1e-6:
            logging.error("X and Y axes are parallel. Cannot define Z axis.")
            slicer.util.errorDisplay(
                "Internal error: X and Y axes are parallel. Cannot define Superior (Z) axis."
            )
            return None
        z_axis_ras = z_axis_ras_unnormalized / norm_z
        logging.info(f"Superior (Z) axis (RAS): {z_axis_ras}")

        matrix = vtk.vtkMatrix4x4()
        matrix.SetElement(0, 0, x_axis_ras[0])
        matrix.SetElement(0, 1, x_axis_ras[1])
        matrix.SetElement(0, 2, x_axis_ras[2])
        matrix.SetElement(0, 3, -np.dot(x_axis_ras, origin_mcp))

        matrix.SetElement(1, 0, y_axis_ras[0])
        matrix.SetElement(1, 1, y_axis_ras[1])
        matrix.SetElement(1, 2, y_axis_ras[2])
        matrix.SetElement(1, 3, -np.dot(y_axis_ras, origin_mcp))

        matrix.SetElement(2, 0, z_axis_ras[0])
        matrix.SetElement(2, 1, z_axis_ras[1])
        matrix.SetElement(2, 2, z_axis_ras[2])
        matrix.SetElement(2, 3, -np.dot(z_axis_ras, origin_mcp))

        matrix.SetElement(3, 0, 0.0)
        matrix.SetElement(3, 1, 0.0)
        matrix.SetElement(3, 2, 0.0)
        matrix.SetElement(3, 3, 1.0)

        logging.info("Successfully created AC-PC transform matrix.")
        return matrix

    def run(self, inputMarkupsNode, outputTransformNode):
        logging.info("AC-PC Transform logic started.")

        if not inputMarkupsNode or not outputTransformNode:
            logging.error("Invalid input or output node for logic.")
            slicer.util.errorDisplay(
                "Invalid input or output node provided to the logic."
            )
            return False

        if inputMarkupsNode.GetNumberOfControlPoints() != 3:
            errorMsg = (
                f"Input markups node '{inputMarkupsNode.GetName()}' must have exactly 3 control points. "
                f"Found {inputMarkupsNode.GetNumberOfControlPoints()}. Points must be AC, PC, IH in order."
            )
            logging.error(errorMsg)
            slicer.util.errorDisplay(errorMsg)
            return False

        p_ac_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(0, p_ac_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(0)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("AC point has not been placed.")
            return False

        p_pc_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(1, p_pc_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(1)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("PC point has not been placed.")
            return False

        p_ih_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(2, p_ih_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(2)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("IH point has not been placed.")
            return False

        transformMatrix = self.createACPCTransformMatrix(
            p_ac_world, p_pc_world, p_ih_world
        )

        if transformMatrix is None:
            logging.error(
                "Failed to create AC-PC transform matrix (error already displayed)."
            )
            return False

        outputTransformNode.SetMatrixTransformToParent(transformMatrix)
        successMsg = f"AC-PC transform '{outputTransformNode.GetName()}' successfully created/updated."
        logging.info(successMsg)
        slicer.util.infoDisplay(successMsg)
        logging.info("AC-PC Transform logic finished.")
        return True


#
# ACPCTransformTest (Unchanged)
#
class ACPCTransformTest(ScriptedLoadableModuleTest):
    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_ACPCTransform_Calculation_Interactive()

    def test_ACPCTransform_Calculation_Interactive(self):
        self.delayDisplay(
            "Starting AC-PC Transform test with simulated interactive placement"
        )
        markupsNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", "TestFiducials"
        )

        pointLabels = ["AC", "PC", "IH"]
        for label in pointLabels:
            markupsNode.AddNPoints(1)
            idx = markupsNode.GetNumberOfControlPoints() - 1
            markupsNode.SetNthControlPointLabel(idx, label)

        ac_coords = [0, 10, 0]
        pc_coords = [0, -10, 0]
        ih_coords = [0, 0, 10]

        markupsNode.SetNthControlPointPositionWorld(0, ac_coords)
        markupsNode.SetNthControlPointPositionStatus(
            0, slicer.vtkMRMLMarkupsNode.PositionDefined
        )
        markupsNode.SetNthControlPointPositionWorld(1, pc_coords)
        markupsNode.SetNthControlPointPositionStatus(
            1, slicer.vtkMRMLMarkupsNode.PositionDefined
        )
        markupsNode.SetNthControlPointPositionWorld(2, ih_coords)
        markupsNode.SetNthControlPointPositionStatus(
            2, slicer.vtkMRMLMarkupsNode.PositionDefined
        )

        outputTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLTransformNode", "TestACPCTransform"
        )
        logic = ACPCTransformLogic()
        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)

        matrix_vtk = vtk.vtkMatrix4x4()
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)
        expected_matrix_elements = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_matrix_elements[r][c],
                    places=5,
                )

        self.delayDisplay("Setting up complex case for test")
        markupsNode.SetNthControlPointPositionWorld(0, [1, 11, 1])
        markupsNode.SetNthControlPointPositionWorld(1, [1, -9, 1])
        markupsNode.SetNthControlPointPositionWorld(2, [1, 1, 11])
        for i in range(3):
            markupsNode.SetNthControlPointPositionStatus(
                i, slicer.vtkMRMLMarkupsNode.PositionDefined
            )

        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)
        expected_elements_complex = [
            [1, 0, 0, -1],
            [0, 1, 0, -1],
            [0, 0, 1, -1],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_elements_complex[r][c],
                    places=5,
                    msg=f"Elem ({r},{c})",
                )
        self.delayDisplay("AC-PC Transform test passed")
