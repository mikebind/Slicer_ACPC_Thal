import qt
import ctk
import slicer
from slicer.ScriptedLoadableModule import *
import vtk
import numpy as np
import logging

#
# ACPCTransform
#


class ACPCTransform(ScriptedLoadableModule):
    """Uses ScriptedLoadableModule base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "AC-PC Transform"
        self.parent.categories = ["Utilities"]
        self.parent.dependencies = []
        self.parent.contributors = ["AI Assistant (Generated)"]
        self.parent.helpText = """
        This module creates a transform to align a volume to the AC-PC (Anterior Commissure - Posterior Commissure) coordinate system.
        Provide a markups fiducial node with three points:
        1. Anterior Commissure (AC)
        2. Posterior Commissure (PC)
        3. An interhemispheric point (IH) - a point in the mid-sagittal plane, typically superior to the AC-PC line.
        The module will generate a vtkMRMLTransformNode.
        """
        self.parent.acknowledgementText = """
        This module was generated by an AI assistant. (Gemini 2.5 Pro (preview), 5/12/2025)
        """


#
# ACPCTransformWidget
#


class ACPCTransformWidget(ScriptedLoadableModuleWidget):
    """Uses ScriptedLoadableModuleWidget base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        # Instantiate and connect widgets ...

        #
        # Parameters Area
        #
        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Parameters"
        self.layout.addWidget(parametersCollapsibleButton)

        # Layout within the dummy collapsible button
        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        #
        # Input Markups Fiducial Node Selector
        #
        self.inputMarkupsSelector = slicer.qMRMLNodeComboBox()
        self.inputMarkupsSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.inputMarkupsSelector.selectNodeUponCreation = False
        self.inputMarkupsSelector.addEnabled = True
        self.inputMarkupsSelector.removeEnabled = False
        self.inputMarkupsSelector.noneEnabled = False
        self.inputMarkupsSelector.showHidden = False
        self.inputMarkupsSelector.showChildNodeTypes = False
        self.inputMarkupsSelector.setMRMLScene(slicer.mrmlScene)
        self.inputMarkupsSelector.setToolTip(
            "Select the Markups Fiducial node containing AC, PC, and IH points (in that order)."
        )
        parametersFormLayout.addRow(
            "Input Fiducials (AC,PC,IH): ", self.inputMarkupsSelector
        )

        #
        # Output Transform Node Selector
        #
        self.outputTransformSelector = slicer.qMRMLNodeComboBox()
        self.outputTransformSelector.nodeTypes = ["vtkMRMLTransformNode"]
        self.outputTransformSelector.selectNodeUponCreation = False
        self.outputTransformSelector.addEnabled = True
        self.outputTransformSelector.removeEnabled = (
            True  # Allow user to remove if they created one by mistake
        )
        self.outputTransformSelector.renameEnabled = True
        self.outputTransformSelector.noneEnabled = (
            False  # Must have an output selected or created
        )
        self.outputTransformSelector.showHidden = False
        self.outputTransformSelector.showChildNodeTypes = False
        self.outputTransformSelector.setMRMLScene(slicer.mrmlScene)
        self.outputTransformSelector.setToolTip(
            "Select or create the output AC-PC transform node."
        )
        parametersFormLayout.addRow(
            "Output AC-PC Transform: ", self.outputTransformSelector
        )

        #
        # Apply Button
        #
        self.applyButton = qt.QPushButton("Apply")
        self.applyButton.toolTip = "Run the AC-PC transform calculation."
        self.applyButton.enabled = False
        parametersFormLayout.addRow(self.applyButton)

        # connections
        self.inputMarkupsSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onSelect
        )
        self.outputTransformSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onSelect
        )
        self.applyButton.connect("clicked(bool)", self.onApplyButton)

        # Add vertical spacer
        self.layout.addStretch(1)

        # Refresh Apply button state
        self.onSelect()

    def cleanup(self):
        pass

    def onSelect(self):
        self.applyButton.enabled = bool(
            self.inputMarkupsSelector.currentNode()
            and self.outputTransformSelector.currentNode()
        )

    def onApplyButton(self):
        logic = ACPCTransformLogic()
        inputMarkupsNode = self.inputMarkupsSelector.currentNode()
        outputTransformNode = self.outputTransformSelector.currentNode()

        if not inputMarkupsNode:
            slicer.util.warningDisplay("Please select an input markups node.")
            return

        if inputMarkupsNode.GetNumberOfControlPoints() < 3:
            slicer.util.warningDisplay(
                f"Input markups node must have at least 3 control points (AC, PC, IH in order). "
                f"Found {inputMarkupsNode.GetNumberOfControlPoints()} points."
            )
            return

        if not outputTransformNode:
            # This should ideally be handled by ensuring a node is always created/selected
            # via the qMRMLNodeComboBox settings if none is chosen.
            # If it's still None, we might auto-create one here, but it's better if the user confirms.
            slicer.util.warningDisplay(
                "Please select or create an output transform node."
            )
            # As a fallback, ensure output node is created if somehow missed
            # outputTransformNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLTransformNode", slicer.mrmlScene.GenerateUniqueName("ACPCTransform"))
            # self.outputTransformSelector.setCurrentNode(outputTransformNode)
            return

        logic.run(inputMarkupsNode, outputTransformNode)


#
# ACPCTransformLogic
#


class ACPCTransformLogic(ScriptedLoadableModuleLogic):
    """This class should implement all the actual
    computation done by your module.  The interface
    should be such that other python code can import
    this class and make use of the functionality without
    requiring an instance of the Widget.
    Uses ScriptedLoadableModuleLogic base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def createACPCTransformMatrix(self, p_ac_np, p_pc_np, p_ih_np):
        """
        Calculates the transformation matrix from RAS to AC-PC space.
        :param p_ac_np: Numpy array for AC point coordinates [x,y,z].
        :param p_pc_np: Numpy array for PC point coordinates [x,y,z].
        :param p_ih_np: Numpy array for IH point coordinates [x,y,z].
        :return: vtk.vtkMatrix4x4 transform matrix, or None if calculation fails.
        """
        logging.info("Calculating AC-PC transform matrix.")
        logging.info(f"AC: {p_ac_np}, PC: {p_pc_np}, IH: {p_ih_np}")

        # Calculate origin (Mid-Commisural Point - MCP)
        origin_mcp = (p_ac_np + p_pc_np) / 2.0
        logging.info(f"Mid-Commisural Point (Origin): {origin_mcp}")

        # Anterior (Y) axis: direction from PC to AC
        y_axis_ras_unnormalized = p_ac_np - p_pc_np
        norm_y = np.linalg.norm(y_axis_ras_unnormalized)
        if norm_y < 1e-6:
            logging.error(
                "AC and PC points are coincident or too close. Cannot define Y axis."
            )
            slicer.util.errorDisplay(
                "AC and PC points are too close. Cannot define Anterior (Y) axis."
            )
            return None
        y_axis_ras = y_axis_ras_unnormalized / norm_y
        logging.info(f"Anterior (Y) axis (RAS): {y_axis_ras}")

        # Right (X) axis: cross product of (AC-PC vector) and (IH-PC vector)
        # Note: The prompt actually states "(PC-AC vector) and (PC-IH vector)".
        # Let's stick to the prompt: X = cross(PC_AC_vec, PC_IH_vec)
        # PC_AC_vec = p_ac_np - p_pc_np  (This is y_axis_ras_unnormalized)
        # PC_IH_vec = p_ih_np - p_pc_np

        # Using prompt's explicit definition: "the cross product of the PC-AC vector and the PC-IH vector"
        # vec_PC_AC = AC - PC (This is consistent with Anterior Y axis)
        # vec_PC_IH = IH - PC
        vec_pc_ac = p_ac_np - p_pc_np  # This is y_axis_ras_unnormalized
        vec_pc_ih = p_ih_np - p_pc_np

        x_axis_ras_unnormalized = np.cross(vec_pc_ac, vec_pc_ih)
        norm_x = np.linalg.norm(x_axis_ras_unnormalized)
        if norm_x < 1e-6:
            logging.error(
                "Points AC, PC, IH are collinear, or PC=AC, or PC=IH. Cannot define X axis."
            )
            slicer.util.errorDisplay(
                "AC, PC, and IH points are likely collinear. Cannot define Right (X) axis (normal to sagittal plane)."
            )
            return None
        x_axis_ras = x_axis_ras_unnormalized / norm_x
        logging.info(f"Right (X) axis (RAS): {x_axis_ras}")

        # Superior (Z) axis: cross product of Right (X) and Anterior (Y) axes
        # Z = X x Y to form a right-handed system (X=Right, Y=Anterior, Z=Superior)
        z_axis_ras_unnormalized = np.cross(x_axis_ras, y_axis_ras)
        norm_z = np.linalg.norm(z_axis_ras_unnormalized)
        if (
            norm_z < 1e-6
        ):  # Should not happen if X and Y are well-defined and not parallel
            logging.error(
                "X and Y axes are parallel (error in calculation). Cannot define Z axis."
            )
            slicer.util.errorDisplay(
                "Internal error: X and Y axes are parallel. Cannot define Superior (Z) axis."
            )
            return None
        z_axis_ras = z_axis_ras_unnormalized / norm_z
        logging.info(f"Superior (Z) axis (RAS): {z_axis_ras}")

        # Construct the transformation matrix from RAS to AC-PC space.
        # This matrix will take a point in RAS and give its coordinates in the new AC-PC system.
        # Rotation part R_RAS_to_ACPC has rows: x_axis_ras, y_axis_ras, z_axis_ras
        # Translation part t_RAS_to_ACPC is -R_RAS_to_ACPC * origin_mcp

        matrix = vtk.vtkMatrix4x4()

        # Row 1 (X_acpc = x_axis_ras . (P_ras - origin_mcp))
        matrix.SetElement(0, 0, x_axis_ras[0])
        matrix.SetElement(0, 1, x_axis_ras[1])
        matrix.SetElement(0, 2, x_axis_ras[2])
        matrix.SetElement(0, 3, -np.dot(x_axis_ras, origin_mcp))

        # Row 2 (Y_acpc = y_axis_ras . (P_ras - origin_mcp))
        matrix.SetElement(1, 0, y_axis_ras[0])
        matrix.SetElement(1, 1, y_axis_ras[1])
        matrix.SetElement(1, 2, y_axis_ras[2])
        matrix.SetElement(1, 3, -np.dot(y_axis_ras, origin_mcp))

        # Row 3 (Z_acpc = z_axis_ras . (P_ras - origin_mcp))
        matrix.SetElement(2, 0, z_axis_ras[0])
        matrix.SetElement(2, 1, z_axis_ras[1])
        matrix.SetElement(2, 2, z_axis_ras[2])
        matrix.SetElement(2, 3, -np.dot(z_axis_ras, origin_mcp))

        # Row 4
        matrix.SetElement(3, 0, 0.0)
        matrix.SetElement(3, 1, 0.0)
        matrix.SetElement(3, 2, 0.0)
        matrix.SetElement(3, 3, 1.0)

        logging.info("Successfully created AC-PC transform matrix.")
        return matrix

    def run(self, inputMarkupsNode, outputTransformNode):
        """
        Run the actual transformation logic.
        :param inputMarkupsNode: The vtkMRMLMarkupsFiducialNode with AC, PC, IH points.
        :param outputTransformNode: The vtkMRMLTransformNode to store the result.
        :return: True if successful, False otherwise.
        """
        logging.info("AC-PC Transform logic started.")

        if not inputMarkupsNode or not outputTransformNode:
            logging.error("Invalid input or output node.")
            slicer.util.errorDisplay(
                "Invalid input or output node provided to the logic."
            )
            return False

        if inputMarkupsNode.GetNumberOfControlPoints() < 3:
            errorMsg = (
                f"Input markups node '{inputMarkupsNode.GetName()}' "
                f"must have at least 3 control points (AC, PC, IH). "
                f"Found {inputMarkupsNode.GetNumberOfControlPoints()}. "
                "Points must be in AC, PC, IH order."
            )
            logging.error(errorMsg)
            slicer.util.errorDisplay(errorMsg)
            return False

        # Get point coordinates as numpy arrays
        # Point 0: AC
        # Point 1: PC
        # Point 2: IH
        p_ac_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(0, p_ac_world)

        p_pc_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(1, p_pc_world)

        p_ih_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(2, p_ih_world)

        transformMatrix = self.createACPCTransformMatrix(
            p_ac_world, p_pc_world, p_ih_world
        )

        if transformMatrix is None:
            # Error already displayed by createACPCTransformMatrix
            logging.error("Failed to create AC-PC transform matrix.")
            return False

        # Set the matrix to the output transform node
        # This transform, when applied to a volume, will map the volume from its original RAS
        # coordinates into the new AC-PC coordinate system.
        outputTransformNode.SetMatrixTransformToParent(transformMatrix)

        successMsg = f"AC-PC transform '{outputTransformNode.GetName()}' successfully created/updated."
        logging.info(successMsg)
        slicer.util.infoDisplay(successMsg)

        logging.info("AC-PC Transform logic finished.")
        return True


class ACPCTransformTest(ScriptedLoadableModuleTest):
    """
    This is the test case for your scripted module.
    Uses ScriptedLoadableModuleTest base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def setUp(self):
        """Do whatever is needed to reset the state - typically a scene clear will be sufficient."""
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        """Run as few or as many tests as needed here."""
        self.setUp()
        self.test_ACPCTransform_Calculation()

    def test_ACPCTransform_Calculation(self):
        self.delayDisplay("Starting AC-PC Transform test")

        # Create mock data
        markupsNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", "TestFiducials"
        )
        # Define AC, PC, IH points (example values)
        # AC: (0, 10, 0)
        # PC: (0, -10, 0)
        # IH: (5, 0, 20) (IH to the right and superior for a clear X axis)
        # If IH is on yz plane, X will be along X.
        # For X axis = cross(PC_AC, PC_IH)
        # PC_AC = (0, 20, 0) (Anterior Y)
        # PC_IH = (5, 10, 20)
        # X_axis = cross((0,20,0), (5,10,20)) = (20*20 - 0*10, 0*5 - 0*20, 0*10 - 20*5)
        #        = (400, 0, -100) -> Points Right-Inferior. This is not ideal for "Right X".
        #
        # Let's re-check the X-axis definition for typical neuroimaging conventions.
        # Often, the mid-sagittal plane is first defined, and X is perpendicular to it.
        # The prompt: "The right (x) axis direction should be in the direction of the normal to the plane
        # defined by the AC, PC and interhemispheric point (the cross product of the PC-AC vector and the PC-IH vector)."
        # My interpretation: PC_AC = AC-PC. PC_IH = IH-PC.
        # X = cross(AC-PC, IH-PC).
        # If AC=(0,10,0), PC=(0,-10,0), IH=(0,0,10) (IH is purely superior, on mid-sagittal plane)
        # AC-PC = (0,20,0) (Anterior)
        # IH-PC = (0,10,10) (Anterior-Superior)
        # X = cross((0,20,0), (0,10,10)) = (20*10 - 0*10, 0*0 - 0*10, 0*10 - 20*0) = (200,0,0) (Right). This is correct.

        ac_coords = [0, 10, 0]
        pc_coords = [0, -10, 0]
        ih_coords = [0, 0, 10]  # IH on the mid-sagittal YZ plane, superior to MCP

        markupsNode.AddControlPoint(vtk.vtkVector3d(ac_coords))
        markupsNode.SetNthControlPointLabel(0, "AC")
        markupsNode.AddControlPoint(vtk.vtkVector3d(pc_coords))
        markupsNode.SetNthControlPointLabel(1, "PC")
        markupsNode.AddControlPoint(vtk.vtkVector3d(ih_coords))
        markupsNode.SetNthControlPointLabel(2, "IH")

        outputTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLTransformNode", "TestACPCTransform"
        )

        logic = ACPCTransformLogic()
        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)

        # Verify Origin (Mid-Commisural Point)
        # MCP = (AC+PC)/2 = (0,0,0)
        # Verify Axes:
        # Y_axis = AC-PC = (0,20,0) -> normalized (0,1,0)
        # X_axis = cross(AC-PC, IH-PC)
        #   AC-PC = (0,20,0)
        #   IH-PC = (0,0,10) - (0,-10,0) = (0,10,10)
        #   X_axis_unnorm = cross((0,20,0), (0,10,10)) = (200,0,0) -> normalized (1,0,0)
        # Z_axis = cross(X_axis, Y_axis) = cross((1,0,0), (0,1,0)) = (0,0,1)

        # The matrix in the node should transform RAS to AC-PC.
        # If P_ras = (0,0,0) (which is MCP), P_acpc should be (0,0,0).
        # Translation part of matrix: -R_RAS_to_ACPC * origin_mcp
        # R_RAS_to_ACPC has rows x_axis_ras=(1,0,0), y_axis_ras=(0,1,0), z_axis_ras=(0,0,1)
        # origin_mcp = (0,0,0)
        # So, translation part is (0,0,0).

        # Matrix should be:
        # [ 1 0 0 0 ]
        # [ 0 1 0 0 ]
        # [ 0 0 1 0 ]
        # [ 0 0 0 1 ] (Identity, because MCP is origin and axes align with RAS axes in this simple case)

        matrix_vtk = vtk.vtkMatrix4x4()
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)

        expected_matrix = np.identity(4)
        # Check elements (allowing for small float inaccuracies)
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c), expected_matrix[r, c], places=5
                )

        # Test a point transformation
        # AC point in RAS is (0,10,0). In AC-PC, it should be (0,10,0) (since MCP is origin, Y_AC=10)
        p_ac_ras = np.array([0, 10, 0, 1])
        p_ac_acpc_homogeneous = np.zeros(4)
        matrix_vtk.MultiplyPoint(p_ac_ras, p_ac_acpc_homogeneous)
        self.assertAlmostEqual(p_ac_acpc_homogeneous[0], 0, places=5)  # X_acpc
        self.assertAlmostEqual(
            p_ac_acpc_homogeneous[1], 10, places=5
        )  # Y_acpc (distance from MCP to AC along Y axis)
        self.assertAlmostEqual(p_ac_acpc_homogeneous[2], 0, places=5)  # Z_acpc

        # PC point in RAS is (0,-10,0). In AC-PC, it should be (0,-10,0)
        p_pc_ras = np.array([0, -10, 0, 1])
        p_pc_acpc_homogeneous = np.zeros(4)
        matrix_vtk.MultiplyPoint(p_pc_ras, p_pc_acpc_homogeneous)
        self.assertAlmostEqual(p_pc_acpc_homogeneous[0], 0, places=5)
        self.assertAlmostEqual(p_pc_acpc_homogeneous[1], -10, places=5)
        self.assertAlmostEqual(p_pc_acpc_homogeneous[2], 0, places=5)

        # Test a more complex case
        # AC=(1,11,1), PC=(1, -9, 1), IH=(1,1,11)
        # MCP = (1,1,1)
        # Y_axis_unnorm = AC-PC = (0,20,0) -> Y_axis = (0,1,0)
        # IH-PC = (1,1,11) - (1,-9,1) = (0,10,10)
        # X_axis_unnorm = cross((0,20,0), (0,10,10)) = (200,0,0) -> X_axis = (1,0,0)
        # Z_axis = cross((1,0,0),(0,1,0)) = (0,0,1)
        # Axes are still aligned with RAS, but origin is (1,1,1)
        # Matrix:
        # [ 1 0 0 -dot((1,0,0),(1,1,1)) ] = [ 1 0 0 -1 ]
        # [ 0 1 0 -dot((0,1,0),(1,1,1)) ] = [ 0 1 0 -1 ]
        # [ 0 0 1 -dot((0,0,1),(1,1,1)) ] = [ 0 0 1 -1 ]
        # [ 0 0 0          1           ]

        self.delayDisplay("Setting up complex case for test")
        markupsNode.SetNthControlPointPositionWorld(0, [1, 11, 1])  # AC
        markupsNode.SetNthControlPointPositionWorld(1, [1, -9, 1])  # PC
        markupsNode.SetNthControlPointPositionWorld(2, [1, 1, 11])  # IH

        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)

        expected_elements = [[1, 0, 0, -1], [0, 1, 0, -1], [0, 0, 1, -1], [0, 0, 0, 1]]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_elements[r][c],
                    places=5,
                    msg=f"Elem ({r},{c})",
                )

        # Transform MCP (1,1,1) to AC-PC space, should be (0,0,0)
        p_mcp_ras = np.array([1, 1, 1, 1])
        p_mcp_acpc_homogeneous = np.zeros(4)
        matrix_vtk.MultiplyPoint(p_mcp_ras, p_mcp_acpc_homogeneous)
        self.assertAlmostEqual(p_mcp_acpc_homogeneous[0], 0, places=5)
        self.assertAlmostEqual(p_mcp_acpc_homogeneous[1], 0, places=5)
        self.assertAlmostEqual(p_mcp_acpc_homogeneous[2], 0, places=5)

        self.delayDisplay("AC-PC Transform test passed")
