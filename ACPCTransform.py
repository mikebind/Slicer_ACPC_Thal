import qt
import ctk
import slicer
from slicer.ScriptedLoadableModule import *
import vtk
import numpy as np
import logging

#
# ACPCTransform
#


class ACPCTransform(ScriptedLoadableModule):
    """Uses ScriptedLoadableModule base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "AC-PC Transform"
        self.parent.categories = ["Utilities", "Registration"]
        self.parent.dependencies = []
        self.parent.contributors = ["AI Assistant (Generated)", "Slicer Community"]
        self.parent.helpText = """
        This module creates a transform to align a volume to the AC-PC (Anterior Commissure - Posterior Commissure) coordinate system.
        It uses an interactive point placement widget.
        1. Select or create a Markups Fiducial node.
        2. If the node is new/empty, it will be pre-populated with "AC", "PC", "IH" unplaced points.
        3. Use the 'Place Points' widget to interactively define the positions of AC, PC, and IH in that order.
        4. Select or create an output Transform node.
        5. Click 'Apply' to generate the AC-PC alignment transform.
        The input fiducials are expected in the order: Anterior Commissure (AC), Posterior Commissure (PC), and an Interhemispheric (IH) point.
        """
        self.parent.acknowledgementText = """
        This module was generated by an AI assistant and incorporates standard Slicer widgets.
        """


#
# ACPCTransformWidget
#


class ACPCTransformWidget(ScriptedLoadableModuleWidget):
    """Uses ScriptedLoadableModuleWidget base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent=None):
        ScriptedLoadableModuleWidget.__init__(self, parent)
        self._observedMarkupsNode = None
        self._markupsObserverTags = []  # Store multiple tags

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        # Instantiate and connect widgets ...

        # Parameters Area
        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Parameters"
        self.layout.addWidget(parametersCollapsibleButton)
        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        # Input Markups Fiducial Node Selector
        self.markupsSelector = slicer.qMRMLNodeComboBox()
        self.markupsSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupsSelector.selectNodeUponCreation = True
        self.markupsSelector.addEnabled = True
        self.markupsSelector.removeEnabled = True
        self.markupsSelector.renameEnabled = True
        self.markupsSelector.noneEnabled = False  # Require a selection or creation
        self.markupsSelector.showHidden = False
        self.markupsSelector.showChildNodeTypes = False
        self.markupsSelector.setMRMLScene(slicer.mrmlScene)
        self.markupsSelector.setToolTip(
            "Select or create the Markups Node for AC, PC, IH points."
        )
        self.markupsSelector.baseName = "ACPCSites"  # Default base name for new nodes
        parametersFormLayout.addRow(
            "Fiducial Points (AC,PC,IH): ", self.markupsSelector
        )

        # Markups Place Widget
        self.markupsPlaceWidget = slicer.qSlicerMarkupsPlaceWidget()
        self.markupsPlaceWidget.setMRMLScene(slicer.mrmlScene)
        # self.markupsPlaceWidget.placeMultipleMarkups = slicer.qSlicerMarkupsPlaceWidget.ForcePlaceMultipleMarkups # Enable continuous placement
        # Let user control this with the widget's own checkbox for "Place multiple markups"
        self.markupsPlaceWidget.buttonsVisible = True  # Show place, delete, etc.
        parametersFormLayout.addRow("Place Points:", self.markupsPlaceWidget)

        # Output Transform Node Selector
        self.outputTransformSelector = slicer.qMRMLNodeComboBox()
        self.outputTransformSelector.nodeTypes = ["vtkMRMLTransformNode"]
        self.outputTransformSelector.selectNodeUponCreation = True
        self.outputTransformSelector.addEnabled = True
        self.outputTransformSelector.removeEnabled = True
        self.outputTransformSelector.renameEnabled = True
        self.outputTransformSelector.noneEnabled = False
        self.outputTransformSelector.showHidden = False
        self.outputTransformSelector.showChildNodeTypes = False
        self.outputTransformSelector.setMRMLScene(slicer.mrmlScene)
        self.outputTransformSelector.setToolTip(
            "Select or create the output AC-PC transform node."
        )
        self.outputTransformSelector.baseName = "ACPCTransform"
        parametersFormLayout.addRow(
            "Output AC-PC Transform: ", self.outputTransformSelector
        )

        # Apply Button
        self.applyButton = qt.QPushButton("Apply")
        self.applyButton.toolTip = "Run the AC-PC transform calculation."
        self.applyButton.enabled = False
        parametersFormLayout.addRow(self.applyButton)

        # Connections
        self.markupsSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onMarkupsNodeSelected
        )
        self.markupsSelector.connect(
            "nodeAddedByUser(vtkMRMLNode*)", self.onMarkupsNodeAddedByUser
        )
        self.outputTransformSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.updateApplyButtonState
        )
        self.applyButton.connect("clicked(bool)", self.onApplyButton)

        # Add vertical spacer
        self.layout.addStretch(1)

        # Initial state
        # If a markups node is already selected (e.g. scene loaded with selection), ensure it's handled
        self.onMarkupsNodeSelected(self.markupsSelector.currentNode())
        self.updateApplyButtonState()

    def cleanup(self):
        ScriptedLoadableModuleWidget.cleanup(self)
        self.removeMarkupObservers()

    def removeMarkupObservers(self):
        if self._observedMarkupsNode and self._markupsObserverTags:
            for tag in self._markupsObserverTags:
                self._observedMarkupsNode.RemoveObserver(tag)
        self._observedMarkupsNode = None
        self._markupsObserverTags = []

    def onMarkupsNodeAddedByUser(self, node):
        # This is called when the user creates a new node using the qMRMLNodeComboBox
        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            logging.debug(f"User added new markups node: {node.GetName()}")
            self.ensureMarkupsNodeIsSetup(node)
        # currentNodeChanged will also be called, which links to place widget and updates UI

    def onMarkupsNodeSelected(self, node):
        logging.debug(
            f"Markups node selection changed to: {node.GetName() if node else 'None'}"
        )
        self.removeMarkupObservers()  # Remove observers from previously selected node

        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            self._observedMarkupsNode = node
            # Observe relevant events to update UI (e.g., enable Apply button)
            events = [
                slicer.vtkMRMLMarkupsNode.PointModifiedEvent,
                slicer.vtkMRMLMarkupsNode.MarkupAddedEvent,
                slicer.vtkMRMLMarkupsNode.MarkupRemovedEvent,
                slicer.vtkMRMLMarkupsNode.PointPositionDefinedEvent,  # Slicer 5.7+
                slicer.vtkMRMLMarkupsNode.PointPositionUndefinedEvent,  # Slicer 5.7+
            ]
            for event in events:
                # Check if event exists in case of Slicer version differences
                if hasattr(slicer.vtkMRMLMarkupsNode, event_name_from_value(event)):
                    tag = node.AddObserver(event, self.onMarkupPointModified)
                    self._markupsObserverTags.append(tag)

            self.ensureMarkupsNodeIsSetup(node)  # Setup if empty
            self.markupsPlaceWidget.setCurrentNode(node)
        else:
            self.markupsPlaceWidget.setCurrentNode(
                None
            )  # No node selected or wrong type

        self.updateApplyButtonState()

    def ensureMarkupsNodeIsSetup(self, markupsNode):
        if not markupsNode or not isinstance(
            markupsNode, slicer.vtkMRMLMarkupsFiducialNode
        ):
            return

        # Only set up if the node is completely empty
        if markupsNode.GetNumberOfControlPoints() == 0:
            logging.info(
                f"Initializing markups node '{markupsNode.GetName()}' with AC, PC, IH unplaced points."
            )
            wasModified = markupsNode.StartModify()
            pointLabels = ["AC", "PC", "IH"]
            for label in pointLabels:
                # AddNPoints adds an unplaced point by default
                markupsNode.AddNPoints(1)
                idx = markupsNode.GetNumberOfControlPoints() - 1
                markupsNode.SetNthControlPointLabel(idx, label)
                # Default position status from AddNPoints is PositionUndefined, which is correct.
            markupsNode.EndModify(wasModified)

            # Optionally, activate placement for the first point immediately
            # This might be too aggressive; user might want to adjust views first.
            # if self.markupsPlaceWidget.currentNode() == markupsNode:
            #     self.markupsPlaceWidget.setPlaceModeEnabled(True)
        else:
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' not empty, skipping auto-setup."
            )

    def onMarkupPointModified(self, caller, event):
        # Called when a point is placed, moved, added, or removed
        logging.debug(
            f"Markup event '{event}' received from {caller.GetName if caller else 'Unknown'}"
        )
        self.updateApplyButtonState()

    def updateApplyButtonState(self):
        markupsNode = self.markupsSelector.currentNode()
        outputNode = self.outputTransformSelector.currentNode()

        readyToApply = False
        if (
            markupsNode
            and isinstance(markupsNode, slicer.vtkMRMLMarkupsFiducialNode)
            and outputNode
            and isinstance(outputNode, slicer.vtkMRMLTransformNode)
        ):
            if markupsNode.GetNumberOfControlPoints() == 3:
                all_points_defined = True
                for i in range(3):
                    if (
                        markupsNode.GetNthControlPointPositionStatus(i)
                        == slicer.vtkMRMLMarkupsNode.PositionUndefined
                    ):
                        all_points_defined = False
                        break
                if all_points_defined:
                    readyToApply = True
        self.applyButton.enabled = readyToApply
        logging.debug(f"Apply button enabled: {readyToApply}")

    def onApplyButton(self):
        logic = ACPCTransformLogic()
        inputMarkupsNode = self.markupsSelector.currentNode()
        outputTransformNode = self.outputTransformSelector.currentNode()

        # Validation already done by updateApplyButtonState for enabling, but double check is fine
        if (
            not inputMarkupsNode
            or not isinstance(inputMarkupsNode, slicer.vtkMRMLMarkupsFiducialNode)
            or inputMarkupsNode.GetNumberOfControlPoints() != 3
        ):
            slicer.util.warningDisplay(
                "Input Markups node must have exactly 3 placed points (AC, PC, IH)."
            )
            return

        all_defined = True
        for i in range(3):
            if (
                inputMarkupsNode.GetNthControlPointPositionStatus(i)
                == slicer.vtkMRMLMarkupsNode.PositionUndefined
            ):
                all_defined = False
                break
        if not all_defined:
            slicer.util.warningDisplay(
                "Not all 3 points (AC, PC, IH) have been placed yet."
            )
            return

        if not outputTransformNode:
            slicer.util.warningDisplay(
                "Please select or create an output transform node."
            )
            return

        logic.run(inputMarkupsNode, outputTransformNode)


# Helper to get event name string (for Slicer versions)
def event_name_from_value(event_value):
    for name, value in slicer.vtkMRMLMarkupsNode.__dict__.items():
        if value == event_value and name.endswith("Event"):
            return name
    return None


#
# ACPCTransformLogic (largely unchanged from previous version)
#
class ACPCTransformLogic(ScriptedLoadableModuleLogic):
    def createACPCTransformMatrix(self, p_ac_np, p_pc_np, p_ih_np):
        logging.info("Calculating AC-PC transform matrix.")
        logging.info(f"AC: {p_ac_np}, PC: {p_pc_np}, IH: {p_ih_np}")

        origin_mcp = (p_ac_np + p_pc_np) / 2.0
        logging.info(f"Mid-Commisural Point (Origin): {origin_mcp}")

        y_axis_ras_unnormalized = p_ac_np - p_pc_np
        norm_y = np.linalg.norm(y_axis_ras_unnormalized)
        if norm_y < 1e-6:
            logging.error(
                "AC and PC points are coincident or too close. Cannot define Y axis."
            )
            slicer.util.errorDisplay(
                "AC and PC points are too close. Cannot define Anterior (Y) axis."
            )
            return None
        y_axis_ras = y_axis_ras_unnormalized / norm_y
        logging.info(f"Anterior (Y) axis (RAS): {y_axis_ras}")

        vec_pc_ac = p_ac_np - p_pc_np
        vec_pc_ih = p_ih_np - p_pc_np

        x_axis_ras_unnormalized = np.cross(vec_pc_ac, vec_pc_ih)
        norm_x = np.linalg.norm(x_axis_ras_unnormalized)
        if norm_x < 1e-6:
            logging.error(
                "Points AC, PC, IH are collinear, or PC=AC, or PC=IH. Cannot define X axis."
            )
            slicer.util.errorDisplay(
                "AC, PC, and IH points are likely collinear. Cannot define Right (X) axis."
            )
            return None
        x_axis_ras = x_axis_ras_unnormalized / norm_x
        logging.info(f"Right (X) axis (RAS): {x_axis_ras}")

        z_axis_ras_unnormalized = np.cross(x_axis_ras, y_axis_ras)
        norm_z = np.linalg.norm(z_axis_ras_unnormalized)
        if norm_z < 1e-6:
            logging.error("X and Y axes are parallel. Cannot define Z axis.")
            slicer.util.errorDisplay(
                "Internal error: X and Y axes are parallel. Cannot define Superior (Z) axis."
            )
            return None
        z_axis_ras = z_axis_ras_unnormalized / norm_z
        logging.info(f"Superior (Z) axis (RAS): {z_axis_ras}")

        matrix = vtk.vtkMatrix4x4()
        matrix.SetElement(0, 0, x_axis_ras[0])
        matrix.SetElement(0, 1, x_axis_ras[1])
        matrix.SetElement(0, 2, x_axis_ras[2])
        matrix.SetElement(0, 3, -np.dot(x_axis_ras, origin_mcp))

        matrix.SetElement(1, 0, y_axis_ras[0])
        matrix.SetElement(1, 1, y_axis_ras[1])
        matrix.SetElement(1, 2, y_axis_ras[2])
        matrix.SetElement(1, 3, -np.dot(y_axis_ras, origin_mcp))

        matrix.SetElement(2, 0, z_axis_ras[0])
        matrix.SetElement(2, 1, z_axis_ras[1])
        matrix.SetElement(2, 2, z_axis_ras[2])
        matrix.SetElement(2, 3, -np.dot(z_axis_ras, origin_mcp))

        matrix.SetElement(3, 0, 0.0)
        matrix.SetElement(3, 1, 0.0)
        matrix.SetElement(3, 2, 0.0)
        matrix.SetElement(3, 3, 1.0)

        logging.info("Successfully created AC-PC transform matrix.")
        return matrix

    def run(self, inputMarkupsNode, outputTransformNode):
        logging.info("AC-PC Transform logic started.")

        if not inputMarkupsNode or not outputTransformNode:
            logging.error("Invalid input or output node for logic.")
            slicer.util.errorDisplay(
                "Invalid input or output node provided to the logic."
            )
            return False

        if inputMarkupsNode.GetNumberOfControlPoints() != 3:
            errorMsg = (
                f"Input markups node '{inputMarkupsNode.GetName()}' must have exactly 3 control points. "
                f"Found {inputMarkupsNode.GetNumberOfControlPoints()}. Points must be AC, PC, IH in order."
            )
            logging.error(errorMsg)
            slicer.util.errorDisplay(errorMsg)
            return False

        p_ac_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(0, p_ac_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(0)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("AC point has not been placed.")
            return False

        p_pc_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(1, p_pc_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(1)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("PC point has not been placed.")
            return False

        p_ih_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(2, p_ih_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(2)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("IH point has not been placed.")
            return False

        transformMatrix = self.createACPCTransformMatrix(
            p_ac_world, p_pc_world, p_ih_world
        )

        if transformMatrix is None:
            logging.error(
                "Failed to create AC-PC transform matrix (error already displayed)."
            )
            return False

        outputTransformNode.SetMatrixTransformToParent(transformMatrix)
        successMsg = f"AC-PC transform '{outputTransformNode.GetName()}' successfully created/updated."
        logging.info(successMsg)
        slicer.util.infoDisplay(successMsg)
        logging.info("AC-PC Transform logic finished.")
        return True


#
# ACPCTransformTest (largely unchanged)
#
class ACPCTransformTest(ScriptedLoadableModuleTest):
    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_ACPCTransform_Calculation_Interactive()  # Updated test name

    def test_ACPCTransform_Calculation_Interactive(self):
        self.delayDisplay(
            "Starting AC-PC Transform test with simulated interactive placement"
        )

        # Create MarkupsNode - this would be done by the widget now
        markupsNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", "TestFiducials"
        )

        # Simulate ensureMarkupsNodeIsSetup
        pointLabels = ["AC", "PC", "IH"]
        for label in pointLabels:
            markupsNode.AddNPoints(1)
            idx = markupsNode.GetNumberOfControlPoints() - 1
            markupsNode.SetNthControlPointLabel(idx, label)

        # Simulate point placement
        ac_coords = [0, 10, 0]
        pc_coords = [0, -10, 0]
        ih_coords = [0, 0, 10]  # IH on the mid-sagittal YZ plane, superior to MCP

        markupsNode.SetNthControlPointPositionWorld(0, ac_coords)  # Places "AC"
        markupsNode.SetNthControlPointPositionStatus(
            0, slicer.vtkMRMLMarkupsNode.PositionDefined
        )
        markupsNode.SetNthControlPointPositionWorld(1, pc_coords)  # Places "PC"
        markupsNode.SetNthControlPointPositionStatus(
            1, slicer.vtkMRMLMarkupsNode.PositionDefined
        )
        markupsNode.SetNthControlPointPositionWorld(2, ih_coords)  # Places "IH"
        markupsNode.SetNthControlPointPositionStatus(
            2, slicer.vtkMRMLMarkupsNode.PositionDefined
        )

        outputTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLTransformNode", "TestACPCTransform"
        )

        logic = ACPCTransformLogic()
        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)

        matrix_vtk = vtk.vtkMatrix4x4()
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)
        expected_matrix_elements = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_matrix_elements[r][c],
                    places=5,
                )

        # Test a more complex case (as in previous version)
        self.delayDisplay("Setting up complex case for test")
        markupsNode.SetNthControlPointPositionWorld(0, [1, 11, 1])  # AC
        markupsNode.SetNthControlPointPositionWorld(1, [1, -9, 1])  # PC
        markupsNode.SetNthControlPointPositionWorld(2, [1, 1, 11])  # IH
        # Ensure position status is Defined (already should be from above)
        for i in range(3):
            markupsNode.SetNthControlPointPositionStatus(
                i, slicer.vtkMRMLMarkupsNode.PositionDefined
            )

        success = logic.run(markupsNode, outputTransformNode)
        self.assertTrue(success)
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)

        expected_elements_complex = [
            [1, 0, 0, -1],
            [0, 1, 0, -1],
            [0, 0, 1, -1],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_elements_complex[r][c],
                    places=5,
                    msg=f"Elem ({r},{c})",
                )

        self.delayDisplay("AC-PC Transform test passed")
