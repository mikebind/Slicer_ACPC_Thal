import qt
import ctk
import slicer
from slicer.ScriptedLoadableModule import *
import vtk
import numpy as np
import logging

#
# ACPCTransform
#


class ACPCTransform(ScriptedLoadableModule):
    """Uses ScriptedLoadableModule base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent):
        ScriptedLoadableModule.__init__(self, parent)
        self.parent.title = "AC-PC Transform"
        self.parent.categories = ["Utilities", "Registration"]
        self.parent.dependencies = []
        self.parent.contributors = [
            "Mike Bindschadler, AI Assistant (Generated)",
            "Slicer Community Resources",
        ]
        self.parent.helpText = """
        This module has a user identify anterior commissure (AC) and posterior commissure (PC) points,
        as well as an inter-hemispheric (IH) point to identify the orienations of the sagittal
        and axial planes. Nodes in the scene can then be rigidly reoriented into the AC-PC coordinate
        system, with the mid-commissural point as the origin. 
        Thalamic nuclei location landmarks can then be marked, starting from a template which
        uses AC-PC coordinates to place initial guesses for CM and ANT nuclei locations. These
        initial guesses can be cycled through and refined by dragging, and PUL locations can
        be freely placed. 
        Results are saved to a DirectTargetingData subdirectory and include the AC-PC-IH point
        locations, all identified ThalamicNuclei locations, and the transformation from 
        initial image locations to AC-PC coordinate system.  
        """
        self.parent.acknowledgementText = """
        This module was partially generated by an AI assistant, and developed by Mike Bindschadler at Seattle Children's Hospital
        """


#
# ACPCTransformWidget
#


class ACPCTransformWidget(ScriptedLoadableModuleWidget):
    """Uses ScriptedLoadableModuleWidget base class, available at:
    https://github.com/Slicer/Slicer/blob/main/Base/Python/slicer/ScriptedLoadableModule.py
    """

    def __init__(self, parent=None):
        ScriptedLoadableModuleWidget.__init__(self, parent)
        self._observedMarkupsNode = None
        self._markupsObserverTags = []
        self._observedNucleiMarkupsNode = None
        self._nucleiMarkupsObserverTags = []
        self.initializeNodes()

    def initializeNodes(self):
        """Create the required AC-PC related transformation nodes"""
        self._netACPCTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLLinearTransformNode", "Total_ACPC_Transform"
        )
        self._incrementalACPCTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLLinearTransformNode", "Step_ACPC_Transform"
        )

    def setup(self):
        ScriptedLoadableModuleWidget.setup(self)

        self.logic = ACPCTransformLogic()

        parametersCollapsibleButton = ctk.ctkCollapsibleButton()
        parametersCollapsibleButton.text = "Parameters"
        self.layout.addWidget(parametersCollapsibleButton)
        parametersFormLayout = qt.QFormLayout(parametersCollapsibleButton)

        # Create AC-PC Template Node Button --- NEW WIDGET ---
        self.createTemplateButton = qt.QPushButton("Create New AC-PC Points Node")
        self.createTemplateButton.toolTip = "Creates and initializes a new Markups Fiducial node for AC, PC, and IH points."
        parametersFormLayout.addRow(self.createTemplateButton)  # Added button here

        # Input Markups Fiducial Node Selector
        self.markupsSelector = slicer.qMRMLNodeComboBox()
        self.markupsSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.markupsSelector.selectNodeUponCreation = (
            False  # We handle selection explicitly
        )
        self.markupsSelector.addEnabled = True  # Still allow creation via combobox too
        self.markupsSelector.removeEnabled = True
        self.markupsSelector.renameEnabled = True
        self.markupsSelector.noneEnabled = (
            True  # Allow no node to be selected initially
        )
        self.markupsSelector.showHidden = False
        self.markupsSelector.showChildNodeTypes = False
        self.markupsSelector.setMRMLScene(slicer.mrmlScene)
        self.markupsSelector.setToolTip(
            "Select or create the Markups Node for AC, PC, IH points."
        )
        self.markupsSelector.baseName = (
            "ACPC_Sites"  # Base name for nodes created by combobox
        )
        parametersFormLayout.addRow(
            "Fiducial Points (AC,PC,IH): ", self.markupsSelector
        )

        # Markups Place Widget
        self.markupsPlaceWidget = slicer.qSlicerMarkupsPlaceWidget()
        self.markupsPlaceWidget.setMRMLScene(slicer.mrmlScene)
        self.markupsPlaceWidget.buttonsVisible = True
        parametersFormLayout.addRow("Place Points:", self.markupsPlaceWidget)

        # Reorient Image Button
        self.reorientButton = qt.QPushButton("Reorient")
        self.reorientButton.toolTip = "Reorient AC-PC"
        self.reorientButton.enabled = False
        parametersFormLayout.addRow(self.reorientButton)

        # Lock/Unlock ACPC points
        self.lockStateButton = qt.QPushButton("Unlock AC-PC-IH Points")
        self.lockStateButton.toolTip = "Place AC-PC-IH points to enable"
        self.lockStateButton.enabled = False
        parametersFormLayout.addRow(self.lockStateButton)

        # Create Nuclei Template Button
        self.createNucleiTemplateButton = qt.QPushButton("Create Nuclei Template")
        self.createNucleiTemplateButton.enabled = False
        self.createNucleiTemplateButton.toolTip = (
            "Create thalamic nuclei template landmarks"
        )
        parametersFormLayout.addRow(self.createNucleiTemplateButton)
        # Nuclei markups selector
        self.nucleiMarkupsSelector = slicer.qMRMLNodeComboBox()
        self.nucleiMarkupsSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode"]
        self.nucleiMarkupsSelector.selectNodeUponCreation = (
            False  # We handle selection explicitly
        )
        self.nucleiMarkupsSelector.addEnabled = (
            True  # Still allow creation via combobox too
        )
        self.nucleiMarkupsSelector.removeEnabled = True
        self.nucleiMarkupsSelector.renameEnabled = True
        self.nucleiMarkupsSelector.noneEnabled = (
            True  # Allow no node to be selected initially
        )
        self.nucleiMarkupsSelector.showHidden = False
        self.nucleiMarkupsSelector.showChildNodeTypes = False
        self.nucleiMarkupsSelector.setMRMLScene(slicer.mrmlScene)
        self.nucleiMarkupsSelector.setToolTip(
            "Select or create the Markups Node for thalamic nuclei."
        )
        self.nucleiMarkupsSelector.baseName = (
            "Nuclei_Sites"  # Base name for nodes created by combobox
        )
        parametersFormLayout.addRow("Nuclei Landmarks: ", self.nucleiMarkupsSelector)
        # Jump to next point (lock previous? place mode if unset)
        self.nextPointButton = qt.QPushButton("Jump To Next Nucleus")
        self.nextPointButton.toolTip = "Jump to next thalamic nucleus point"
        self.nextPointButton.enabled = False
        parametersFormLayout.addRow(self.nextPointButton)
        # Previous point button
        self.previousPointButton = qt.QPushButton("Jump to Previous Nucleus")
        self.previousPointButton.toolTip = "Jump to previous thalamic nucleus point"
        self.previousPointButton.enabled = False
        parametersFormLayout.addRow(self.previousPointButton)
        # Save button
        self.saveButton = qt.QPushButton("Save Final Locations")
        self.saveButton.toolTip = "Save results to files (also clears scene!)"
        self.saveButton.enabled = True
        parametersFormLayout.addRow(self.saveButton)
        # Load button
        self.loadButton = qt.QPushButton("Reload Saved Data")
        self.loadButton.toolTip = "Load saved results for current patient from files"
        self.loadButton.enabled = True
        parametersFormLayout.addRow(self.loadButton)

        # Connections
        self.createTemplateButton.connect(
            "clicked(bool)", self.onCreateACPCTemplateNode
        )
        self.markupsSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onMarkupsNodeSelected
        )
        self.markupsSelector.connect(
            "nodeAddedByUser(vtkMRMLNode*)", self.onMarkupsNodeAddedByUser
        )
        self.reorientButton.connect("clicked(bool)", self.onReorientButton)
        self.lockStateButton.connect("clicked(bool)", self.onLockStateButton)
        self.createNucleiTemplateButton.connect(
            "clicked(bool)", self.onCreateNucleiTemplateButton
        )
        self.nucleiMarkupsSelector.connect(
            "currentNodeChanged(vtkMRMLNode*)", self.onNucleiMarkupsNodeSelected
        )
        self.nextPointButton.connect("clicked(bool)", self.onNextPointButton)
        self.previousPointButton.connect("clicked(bool)", self.onPreviousPointButton)
        self.saveButton.connect("clicked(bool)", self.onSaveButton)
        self.loadButton.connect("clicked(bool)", self.onLoadButton)

        self.layout.addStretch(1)
        # Initial setup call for markups node if one is already selected from previous session/scene
        if self.markupsSelector.currentNode():
            self.onMarkupsNodeSelected(self.markupsSelector.currentNode())
        else:  # Ensure place widget is cleared if no node is selected initially
            self.markupsPlaceWidget.setCurrentNode(None)
        #
        self.logic.setSliceIntersectionVisibility(True)

    def cleanup(self):
        ScriptedLoadableModuleWidget.cleanup(self)
        self.removeMarkupObservers()
        self.removeNucleiMarkupObservers()

    def removeMarkupObservers(self):
        if self._observedMarkupsNode and self._markupsObserverTags:
            for tag in self._markupsObserverTags:
                try:
                    self._observedMarkupsNode.RemoveObserver(tag)
                except AttributeError:  # Node might have been deleted from scene
                    logging.debug(
                        "Could not remove observer, node might be already deleted."
                    )
        self._observedMarkupsNode = None
        self._markupsObserverTags = []

    def removeNucleiMarkupObservers(self):
        if self._observedNucleiMarkupsNode and self._nucleiMarkupsObserverTags:
            for tag in self._nucleiMarkupsObserverTags:
                try:
                    self._observedNucleiMarkupsNode.RemoveObserver(tag)
                except AttributeError:
                    logging.debug(
                        "Could not remove observer, node might be already deleted."
                    )
        self._observedNucleiMarkupsNode = None
        self._nucleiMarkupsObserverTags = []

    def onCreateACPCTemplateNode(self):
        logging.debug("onCreateACPCTemplateNode called")
        baseName = (
            self.markupsSelector.baseName
            if self.markupsSelector.baseName
            else "ACPCSites_New"
        )
        newNodeName = slicer.mrmlScene.GenerateUniqueName(baseName)

        newNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", newNodeName
        )
        if not newNode:
            logging.error(f"Failed to create new markups node: {newNodeName}")
            slicer.util.errorDisplay(
                f"Could not create new Markups Fiducial node: {newNodeName}"
            )
            return

        logging.info(f"Created new markups node via button: {newNode.GetName()}")

        # ensureMarkupsNodeIsSetup will populate AC, PC, IH
        # onMarkupsNodeSelected (triggered by setCurrentNode) will also call ensureMarkupsNodeIsSetup.
        # To avoid double setup or issues if ensureMarkupsNodeIsSetup isn't idempotent for an empty node,
        # we can call it directly here, and onMarkupsNodeSelected will correctly link observers and place widget.
        self.ensureMarkupsNodeIsSetup(newNode)
        # Set some convenient display properties
        self.logic.standardizeACPCDisplay(newNode)

        self.markupsSelector.setCurrentNode(newNode)
        # setCurrentNode will trigger onMarkupsNodeSelected, which will:
        # 1. Set up observers
        # 2. Call ensureMarkupsNodeIsSetup again (it's safe as it checks for empty node)
        # 3. Link self.markupsPlaceWidget.setCurrentNode(newNode)
        # 4. Update apply button state

    def onMarkupsNodeAddedByUser(self, node):
        # This is called when the user creates a new node using the qMRMLNodeComboBox's "Create new..."
        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            logging.debug(f"User added new markups node via ComboBox: {node.GetName()}")
            # ensureMarkupsNodeIsSetup is called by onMarkupsNodeSelected,
            # which is triggered when currentNodeChanged signal is emitted after node creation.
            # No need to call it explicitly here if onMarkupsNodeSelected is robust.

    def onMarkupsNodeSelected(self, node):
        logging.debug(
            f"Markups node selection changed to: {node.GetName() if node else 'None'}"
        )
        self.removeMarkupObservers()  # Clear observers from any previously selected node

        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            self._observedMarkupsNode = node

            core_event_ids = [
                slicer.vtkMRMLMarkupsNode.PointModifiedEvent,
                slicer.vtkMRMLMarkupsNode.PointAddedEvent,
                slicer.vtkMRMLMarkupsNode.PointRemovedEvent,
            ]
            for event_id in core_event_ids:
                tag = node.AddObserver(event_id, self.onMarkupPointModified)
                self._markupsObserverTags.append(tag)
                logging.debug(
                    f"Added observer for event ID {event_id} on node {node.GetName()}"
                )

            newer_event_names = [
                "PointPositionDefinedEvent",
                "PointPositionUndefinedEvent",
            ]
            for event_name_str in newer_event_names:
                if hasattr(
                    slicer.vtkMRMLMarkupsNode, event_name_str
                ):  # Check if the attribute (event ID) exists
                    event_id = getattr(slicer.vtkMRMLMarkupsNode, event_name_str)
                    tag = node.AddObserver(event_id, self.onMarkupPointModified)
                    self._markupsObserverTags.append(tag)
                    logging.debug(
                        f"Added observer for {event_name_str} (ID: {event_id}) on node {node.GetName()}"
                    )

            self.ensureMarkupsNodeIsSetup(node)  # Setup the node if it's empty
            self.markupsPlaceWidget.setCurrentNode(node)  # Link the place widget
        else:
            self.markupsPlaceWidget.setCurrentNode(
                None
            )  # No valid node selected, clear place widget
        # Update button state
        self.updateReorientButtonState()
        self.updateLockStateButtonState()

    def onNucleiMarkupsNodeSelected(self, node):
        """ """
        # Handle observers (mimicing onMarkupsNodeSelected, not sure how necessary this is)
        logging.debug(
            f"Markups node selection changed to: {node.GetName() if node else 'None'}"
        )
        self.removeNucleiMarkupObservers()  # Clear observers from any previously selected node

        if node and isinstance(node, slicer.vtkMRMLMarkupsFiducialNode):
            self._observedNucleiMarkupsNode = node

            core_event_ids = [
                slicer.vtkMRMLMarkupsNode.PointModifiedEvent,
                slicer.vtkMRMLMarkupsNode.PointAddedEvent,
                slicer.vtkMRMLMarkupsNode.PointRemovedEvent,
            ]
            for event_id in core_event_ids:
                tag = node.AddObserver(event_id, self.onNucleiMarkupPointModified)
                self._nucleiMarkupsObserverTags.append(tag)
                logging.debug(
                    f"Added observer for event ID {event_id} on node {node.GetName()}"
                )

            newer_event_names = [
                "PointPositionDefinedEvent",
                "PointPositionUndefinedEvent",
            ]
            for event_name_str in newer_event_names:
                if hasattr(
                    slicer.vtkMRMLMarkupsNode, event_name_str
                ):  # Check if the attribute (event ID) exists
                    event_id = getattr(slicer.vtkMRMLMarkupsNode, event_name_str)
                    tag = node.AddObserver(event_id, self.onNucleiMarkupPointModified)
                    self._nucleiMarkupsObserverTags.append(tag)
                    logging.debug(
                        f"Added observer for {event_name_str} (ID: {event_id}) on node {node.GetName()}"
                    )
        # Set up if empty
        self.ensureNucleiMarkupsNodeIsSetup(node)
        if node:
            self.logic.lockAllControlPoints(node)
        # Handle related button states
        self.updateNextPointButtonState()
        self.updatePreviousPointButtonState()
        self.updateSaveButtonState()

    def ensureMarkupsNodeIsSetup(self, markupsNode):
        if not markupsNode or not isinstance(
            markupsNode, slicer.vtkMRMLMarkupsFiducialNode
        ):
            return

        # Only initialize if the node is completely empty.
        if markupsNode.GetNumberOfControlPoints() == 0:
            logging.info(
                f"Initializing markups node '{markupsNode.GetName()}' with AC, PC, IH unplaced points."
            )
            wasModified = markupsNode.StartModify()
            pointLabels = ["AC", "PC", "IH"]
            for label_text in pointLabels:
                newPointIndex = markupsNode.AddControlPoint([0.0, 0.0, 0.0], label_text)
                markupsNode.UnsetNthControlPointPosition(newPointIndex)
            markupsNode.EndModify(wasModified)
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' initialized. Number of points: {markupsNode.GetNumberOfControlPoints()}"
            )
        else:
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' not empty ({markupsNode.GetNumberOfControlPoints()} points), skipping auto-setup."
            )

    def ensureNucleiMarkupsNodeIsSetup(self, markupsNode):
        if not markupsNode or not isinstance(
            markupsNode, slicer.vtkMRMLMarkupsFiducialNode
        ):
            return

        # Only initialize if the node is completely empty.
        if markupsNode.GetNumberOfControlPoints() == 0:
            logging.info(
                f"Initializing markups node '{markupsNode.GetName()}' with CM, ANT, and unplaced PUL points."
            )
            wasModified = markupsNode.StartModify()
            self.logic.initializeThalNucMarkups(markupsNode)
            markupsNode.EndModify(wasModified)
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' initialized. Number of points: {markupsNode.GetNumberOfControlPoints()}"
            )
        else:
            logging.debug(
                f"Markups node '{markupsNode.GetName()}' not empty ({markupsNode.GetNumberOfControlPoints()} points), skipping auto-setup."
            )

    def onMarkupPointModified(self, caller, event):
        # Check if caller (node) still exists, as it might be deleted during scene close
        if slicer.mrmlScene.IsNodePresent(caller):
            logging.debug(
                f"Markup event (ID: {event}) received from {caller.GetName()}"
            )
            self.updateReorientButtonState()
            self.updateLockStateButtonState()
        else:
            logging.debug(
                f"Markup event (ID: {event}) received from a deleted node. Ignoring."
            )

    def onNucleiMarkupPointModified(self, caller, event):
        # Check if caller (node) still exists, as it might be deleted during scene close
        if slicer.mrmlScene.IsNodePresent(caller):
            logging.debug(
                f"Markup event (ID: {event}) received from {caller.GetName()}"
            )
            self.updateNextPointButtonState()
            self.updatePreviousPointButtonState()
            self.updateSaveButtonState()
        else:
            logging.debug(
                f"Markup event (ID: {event}) received from a deleted node. Ignoring."
            )

    def updateReorientButtonState(self):
        """Enable Reorient whenever there are 3 AC-PC-IH points and they aren't aligned
        properly (coords within 1e-4 of expected).  Disable and change label to
        "Already Oriented" if properly aligned.  Keep label Reorient but disabled
        if not 3 placed points yet.
        """
        markupsNode = self.markupsSelector.currentNode()
        pointsDefinedFlag = self.logic.checkPointsDefined(markupsNode)
        if pointsDefinedFlag:
            alignedFlag = self.logic.checkAligned(markupsNode)
            if alignedFlag:
                # Already oriented, disable and label
                self.reorientButton.enabled = False
                self.reorientButton.text = "Already AC-PC Oriented"
                self.reorientButton.toolTip = (
                    "AC-PC-IH points indicate that orientation is already correct"
                )
                logging.debug(
                    "Reorient button state: disabled due to existing correct orientation"
                )
                self.updateNucleiTemplateButtonState()
            else:
                # Points defined but not aligned
                self.reorientButton.enabled = True
                self.reorientButton.text = "Reorient to AC-PC"
                self.reorientButton.toolTip = "Use AC-PC-IH points to reorient all images, models, and markups to AC-PC coordinate system"
                logging.debug("Reorient button state: enabled")
        else:
            # Points not defined yet
            self.reorientButton.enabled = False
            self.reorientButton.text = "Reorient to AC-PC"
            self.reorientButton.toolTip = (
                "Select AC, PC, and IH points to enable reorientation"
            )
            logging.debug("Reorient button state: disabled due to missing point(s)")

    def updateLockStateButtonState(self):
        """Enable if AC-PC-IH markups is selected.  Change text to Unlock if control
        points are locked, to Lock if control points are unlocked.
        """
        markup = self.markupsSelector.currentNode()
        enabled = markup is not None and markup.GetNumberOfControlPoints() > 0
        self.lockStateButton.enabled = enabled
        if enabled:
            firstPointLocked = bool(markup.GetNthControlPointLocked(0))
            if firstPointLocked:
                buttonText = "Unlock AC-PC-IH Points"
                tip = "Allow AC-PC-IH points to be dragged in order to fine tune and then reorient"
            else:
                buttonText = "Lock AC-PC-IH Points"
                tip = "Prevent accidental dragging of AC-PC-IH points"
        else:
            buttonText = "Lock AC-PC-IH Points"
            tip = "Place AC-PC-IH points to enable"
        self.lockStateButton.text = buttonText
        self.lockStateButton.toolTip = tip

    def updateNextPointButtonState(self):
        """Enable button if there is a nuclei markups node selected"""
        markupsNode = self.nucleiMarkupsSelector.currentNode()
        readyToApply = False
        if markupsNode:
            readyToApply = True
        self.nextPointButton.enabled = readyToApply
        logging.debug(f"Next Point button enabled: {readyToApply}")

    def updatePreviousPointButtonState(self):
        """Enable button if there is a nuclei markups node selected"""
        markupsNode = self.nucleiMarkupsSelector.currentNode()
        readyToApply = False
        if markupsNode:
            readyToApply = True
        self.previousPointButton.enabled = readyToApply
        logging.debug(f"Previous Point button enabled: {readyToApply}")

    def updateSaveButtonState(self):
        """Enable button if there is a nuclei markups node selected"""
        markupsNode = self.nucleiMarkupsSelector.currentNode()
        readyToApply = False
        if markupsNode:
            readyToApply = True
        self.saveButton.enabled = readyToApply
        logging.debug(f"Save button enabled: {readyToApply}")

    def updateNucleiTemplateButtonState(self):
        """Update enabled state of the nuclei template creation
        button according to whether acpc points are defined and
        aligned
        """
        markupsNode = self.markupsSelector.currentNode()
        button = self.createNucleiTemplateButton
        pointsDefinedFlag = False
        alignedFlag = False
        if markupsNode:
            pointsDefinedFlag = self.logic.checkPointsDefined(markupsNode)
        if pointsDefinedFlag:
            alignedFlag = self.logic.checkAligned(markupsNode)
        enableFlag = pointsDefinedFlag and alignedFlag
        button.enabled = enableFlag
        if enableFlag:
            button.toolTip = (
                "Create markups template for Thalamic Nuclei in default locations"
            )
            logging.debug("Create Nuclei Template button enabled: True")
        elif not pointsDefinedFlag:
            button.toolTip = "Define AC-PC-IH points and reorient to enable!"
            logging.debug(
                "Create Nuclei Template button enabled: False (points missing)"
            )
        elif not alignedFlag:
            button.toolTip = "Reorient to enable!"
            logging.debug(
                "Create Nuclei Template button enabled: False (reorientation needed)"
            )

    def onCalculateTransformButton(self):
        inputMarkupsNode = self.markupsSelector.currentNode()
        outputTransformNode = self.outputTransformSelector.currentNode()

        if (
            not inputMarkupsNode
            or not isinstance(inputMarkupsNode, slicer.vtkMRMLMarkupsFiducialNode)
            or inputMarkupsNode.GetNumberOfControlPoints() != 3
        ):
            slicer.util.warningDisplay(
                "Input Markups node must have exactly 3 placed points (AC, PC, IH)."
            )
            return

        all_defined = True
        for i in range(3):
            if (
                inputMarkupsNode.GetNthControlPointPositionStatus(i)
                == slicer.vtkMRMLMarkupsNode.PositionUndefined
            ):
                all_defined = False
                break
        if not all_defined:
            slicer.util.warningDisplay(
                "Not all 3 points (AC, PC, IH) have been placed yet."
            )
            return

        if not outputTransformNode:
            slicer.util.warningDisplay(
                "Please select or create an output transform node."
            )
            return

        self.logic.calculateACPCTransform(inputMarkupsNode, outputTransformNode)

    def onCreateNucleiTemplateButton(self):
        logging.debug("onCreateNucleiTemplateButton called")
        baseName = (
            self.nucleiMarkupsSelector.baseName
            if self.nucleiMarkupsSelector.baseName
            else "Nuclei_Sites_New"
        )
        newNodeName = slicer.mrmlScene.GenerateUniqueName(baseName)

        newNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", newNodeName
        )
        if not newNode:
            logging.error(f"Failed to create new markups node: {newNodeName}")
            slicer.util.errorDisplay(
                f"Could not create new Markups Fiducial node: {newNodeName}"
            )
            return

        logging.info(f"Created new markups node via button: {newNode.GetName()}")

        # ensureMarkupsNodeIsSetup will populate AC, PC, IH
        # onNucleiMarkupsNodeSelected (triggered by setCurrentNode) will also call ensureMarkupsNodeIsSetup.
        # To avoid double setup or issues if ensureMarkupsNodeIsSetup isn't idempotent for an empty node,
        # we can call it directly here, and onNucleiMarkupsNodeSelected will correctly link observers and place widget.
        self.ensureNucleiMarkupsNodeIsSetup(newNode)
        self.logic.standardizeNucleiPointsDisplay(newNode)

        self.nucleiMarkupsSelector.setCurrentNode(newNode)
        # setCurrentNode will trigger onNucleiMarkupsNodeSelected, which will:
        # 1. Set up observers
        # 2. Call ensureNucleiMarkupsNodeIsSetup again (it's safe as it checks for empty node)
        # 3. Update button states

    def onReorientButton(self):
        """Calculate, then apply, AC-PC transform to everything (all
        image, labelmap, model, and markups nodes).
        Any initial transform hierarchy is hardened first, then the AC-PC
        Transform is applied and hardened.
        """
        acpcMarkupsNode = self.markupsSelector.currentNode()
        # Calculate the transform
        acpcTransformNode = self.logic.calculateACPCTransform(acpcMarkupsNode)
        self._incrementalACPCTransformNode = acpcTransformNode
        # Add incremental transformation to the net transformation
        self._netACPCTransformNode.SetAndObserveTransformNodeID(
            acpcTransformNode.GetID()
        )
        self._netACPCTransformNode.HardenTransform()

        # Harden any existing soft transforms on images, models, and markups
        self.logic.hardenAllTransforms()
        # Apply the acpc transform to everything
        self.logic.applyTransformToAll(acpcTransformNode)
        # Lock AC-PC markups so no accidental modification
        self.logic.lockAllControlPoints(acpcMarkupsNode)
        # Align slice views, jump to center on PC, enable nuclei template button
        self.logic.reorientSlices()
        self.jumpToPC()
        self.updateNucleiTemplateButtonState()

    def onLockStateButton(self):
        """Lock or unlock AC-PC-IH markups control points"""
        markup = self.markupsSelector.currentNode()
        if markup is not None:
            unlockFlag = self.lockStateButton.text[0] == "U"
            if unlockFlag:
                self.logic.unlockAllControlPoints(markup)
            else:
                self.logic.lockAllControlPoints(markup)
        self.updateLockStateButtonState()

    def jumpToPC(self):
        """Jump slice views to the posterior commissure point"""
        acpcMarkup = self.markupsSelector.currentNode()
        pcPos = acpcMarkup.GetNthControlPointPositionWorld(1)
        self.logic.jumpToPosition(pcPos)

    def onNextPointButton(self):
        nucleiMarkup = self.nucleiMarkupsSelector.currentNode()
        self.logic.setSliceIntersectionVisibility(True)
        self.logic.jumpToNextPoint(nucleiMarkup)

    def onPreviousPointButton(self):
        nucleiMarkup = self.nucleiMarkupsSelector.currentNode()
        self.logic.setSliceIntersectionVisibility(True)
        self.logic.jumpToPreviousPoint(nucleiMarkup)

    def onSaveButton(self):
        """What needs to be saved?
        * AC-PC coordinates of each nucleus, which is just the
          nucleiMarkup control point positions.
        * Net AC-PC transformation matrix
        * Might as well also save AC-PC points
        """
        from slicer.util import infoDisplay

        acpcMarkup = self.markupsSelector.currentNode()
        nucleiMarkup = self.nucleiMarkupsSelector.currentNode()
        # idea: save thalNuclei ijkToRas matrix as a way to
        # link studies processed in different orders?
        self.logic.save(acpcMarkup, nucleiMarkup, self._netACPCTransformNode)
        infoDisplay(
            f"Results saved! The scene will be cleared to prepare for loading the next case."
        )
        self.reset()

    def onLoadButton(self):
        """To allow adjustment of saved ACPC alignment and nuclei locations"""
        # NOTE: Block or undo current net transformation, or else could get confused
        from slicer.util import updateTransformMatrixFromArray, errorDisplay, getNode

        # Check that there are relevant loaded nodes in the scene
        nodes = self.logic.gatherNodesToHarden()
        if len(nodes) == 0:
            errorDisplay("Load an MRB bundle file first before reloading ACPC data!")
            return
        try:
            currentNetTransformNode = getNode("Total_ACPC_Transform")
        except:
            # Scene is missing this node, create
            self.initializeNodes()
        if not self._netACPCTransformNode:
            # self is missing this node, create
            self.initializeNodes()
        acpcMarkup, nucleiMarkup, netTransformMatrix = self.logic.load(
            None,
            self._netACPCTransformNode,
            self.markupsSelector.currentNode(),
            self.nucleiMarkupsSelector.currentNode(),
        )
        # Replace transform matrix in initialized transform nodes
        updateTransformMatrixFromArray(self._netACPCTransformNode, netTransformMatrix)
        self._incrementalACPCTransformNode = None
        # Select loaded nodes in selectors
        self.markupsSelector.setCurrentNode(acpcMarkup)
        self.nucleiMarkupsSelector.setCurrentNode(nucleiMarkup)
        self.logic.reorientSlices()
        self.jumpToPC()

    def reset(self):
        """Reset the state of the module to be able to start a new
        case from a clean slate. Close the scene, reset counters, remove
        observers, then re-intialize.
        """
        self.removeMarkupObservers()
        self.removeNucleiMarkupObservers()
        slicer.mrmlScene.Clear()
        # Re-intialize
        self.initializeNodes()
        self.logic._currentPointIdx = None


#
# ACPCTransformLogic (Unchanged)
#
class ACPCTransformLogic(ScriptedLoadableModuleLogic):
    def __init__(self):
        self._currentPointIdx = None

    def createACPCTransformMatrix(self, p_ac_np, p_pc_np, p_ih_np):
        logging.info("Calculating AC-PC transform matrix.")
        logging.info(f"AC: {p_ac_np}, PC: {p_pc_np}, IH: {p_ih_np}")

        origin_mcp = (p_ac_np + p_pc_np) / 2.0
        logging.info(f"Mid-Commisural Point (Origin): {origin_mcp}")

        y_axis_ras_unnormalized = p_ac_np - p_pc_np
        norm_y = np.linalg.norm(y_axis_ras_unnormalized)
        if norm_y < 1e-6:
            logging.error(
                "AC and PC points are coincident or too close. Cannot define Y axis."
            )
            slicer.util.errorDisplay(
                "AC and PC points are too close. Cannot define Anterior (Y) axis."
            )
            return None
        y_axis_ras = y_axis_ras_unnormalized / norm_y
        logging.info(f"Anterior (Y) axis (RAS): {y_axis_ras}")

        vec_pc_ac = p_ac_np - p_pc_np
        vec_pc_ih = p_ih_np - p_pc_np

        x_axis_ras_unnormalized = np.cross(vec_pc_ac, vec_pc_ih)
        norm_x = np.linalg.norm(x_axis_ras_unnormalized)
        if norm_x < 1e-6:
            logging.error(
                "Points AC, PC, IH are collinear, or PC=AC, or PC=IH. Cannot define X axis."
            )
            slicer.util.errorDisplay(
                "AC, PC, and IH points are likely collinear. Cannot define Right (X) axis."
            )
            return None
        x_axis_ras = x_axis_ras_unnormalized / norm_x
        logging.info(f"Right (X) axis (RAS): {x_axis_ras}")

        z_axis_ras_unnormalized = np.cross(x_axis_ras, y_axis_ras)
        norm_z = np.linalg.norm(z_axis_ras_unnormalized)
        if norm_z < 1e-6:
            logging.error("X and Y axes are parallel. Cannot define Z axis.")
            slicer.util.errorDisplay(
                "Internal error: X and Y axes are parallel. Cannot define Superior (Z) axis."
            )
            return None
        z_axis_ras = z_axis_ras_unnormalized / norm_z
        logging.info(f"Superior (Z) axis (RAS): {z_axis_ras}")

        matrix = vtk.vtkMatrix4x4()
        matrix.SetElement(0, 0, x_axis_ras[0])
        matrix.SetElement(0, 1, x_axis_ras[1])
        matrix.SetElement(0, 2, x_axis_ras[2])
        matrix.SetElement(0, 3, -np.dot(x_axis_ras, origin_mcp))

        matrix.SetElement(1, 0, y_axis_ras[0])
        matrix.SetElement(1, 1, y_axis_ras[1])
        matrix.SetElement(1, 2, y_axis_ras[2])
        matrix.SetElement(1, 3, -np.dot(y_axis_ras, origin_mcp))

        matrix.SetElement(2, 0, z_axis_ras[0])
        matrix.SetElement(2, 1, z_axis_ras[1])
        matrix.SetElement(2, 2, z_axis_ras[2])
        matrix.SetElement(2, 3, -np.dot(z_axis_ras, origin_mcp))

        matrix.SetElement(3, 0, 0.0)
        matrix.SetElement(3, 1, 0.0)
        matrix.SetElement(3, 2, 0.0)
        matrix.SetElement(3, 3, 1.0)

        logging.info("Successfully created AC-PC transform matrix.")
        return matrix

    def calculateACPCTransform(self, inputMarkupsNode):
        logging.info("AC-PC Transform logic started.")
        scene = slicer.mrmlScene
        outputTransformNode = scene.AddNewNodeByClass("vtkMRMLLinearTransformNode")
        uniqName = scene.GenerateUniqueName("AC_PC_Transform")
        outputTransformNode.SetName(uniqName)

        if inputMarkupsNode.GetNumberOfControlPoints() != 3:
            errorMsg = (
                f"Input markups node '{inputMarkupsNode.GetName()}' must have exactly 3 control points. "
                f"Found {inputMarkupsNode.GetNumberOfControlPoints()}. Points must be AC, PC, IH in order."
            )
            logging.error(errorMsg)
            slicer.util.errorDisplay(errorMsg)
            return None

        p_ac_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(0, p_ac_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(0)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("AC point has not been placed.")
            return None

        p_pc_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(1, p_pc_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(1)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("PC point has not been placed.")
            return None

        p_ih_world = np.zeros(3)
        inputMarkupsNode.GetNthControlPointPositionWorld(2, p_ih_world)
        if (
            inputMarkupsNode.GetNthControlPointPositionStatus(2)
            == slicer.vtkMRMLMarkupsNode.PositionUndefined
        ):
            slicer.util.errorDisplay("IH point has not been placed.")
            return None

        transformMatrix = self.createACPCTransformMatrix(
            p_ac_world, p_pc_world, p_ih_world
        )

        if transformMatrix is None:
            logging.error(
                "Failed to create AC-PC transform matrix (error already displayed)."
            )
            return None

        outputTransformNode.SetMatrixTransformToParent(transformMatrix)
        successMsg = f"AC-PC transform '{outputTransformNode.GetName()}' successfully created/updated."
        logging.info(successMsg)
        # slicer.util.infoDisplay(successMsg)
        logging.info("AC-PC Transform logic finished.")
        return outputTransformNode

    def standardizeACPCDisplay(self, markupsNode):
        """Set display node properties for marksupsNode"""
        markupsNode.CreateDefaultDisplayNodes()
        dn = markupsNode.GetDisplayNode()
        dn.SetGlyphScale(1)
        dn.SetUseGlyphScale(True)
        dn.SetSelectedColor((1.0, 0.0, 0.0))  # red

    def standardizeNucleiPointsDisplay(self, markupsNode):
        """Set display node properties for marksupsNode"""
        markupsNode.CreateDefaultDisplayNodes()
        dn = markupsNode.GetDisplayNode()
        dn.SetGlyphScale(1)
        dn.SetUseGlyphScale(True)
        dn.SetSelectedColor((0.0, 1.0, 1.0))  # cyan
        dn.SetColor((1.0, 0.0, 1.0))  # magenta

    def checkPointsDefined(self, markupsNode):
        """Check that there are 3 points and they have defined positions.
        Return true if both conditions satisfied.
        """
        if not markupsNode:
            return False
        atLeastThreePoints = markupsNode.GetNumberOfControlPoints() >= 3
        if atLeastThreePoints:
            pointsDefined = True
            for idx in range(3):
                if (
                    markupsNode.GetNthControlPointPositionStatus(idx)
                    == slicer.vtkMRMLMarkupsNode.PositionUndefined
                ):
                    pointsDefined = False
                    break
            return pointsDefined
        else:
            return False

    def checkAligned(self, markupsNode, tol=1e-4):
        """Check whether the first three control points of the markups node
        look like they could be the AC, PC, IH points in the AC PC coordinate
        system. The conditions checked are
         * AC and PC points have |R| and |S| coordinates < tol
         * AC and PC, A coordinate average < tol (origin should be MCP)
         * IH should have S coord > 0 and |R| coord < tol
        If all conditions are met, returns True, else returns False
        """
        if not markupsNode:
            return False
        pts = slicer.util.arrayFromMarkupsControlPoints(markupsNode, world=True)
        AC = pts[0]
        PC = pts[1]
        IH = pts[2]
        aligned = True
        if not all(
            (
                np.abs(AC[0]) < tol,  # AC on R=0 plane
                np.abs(PC[0]) < tol,  # PC on R=0 plane
                np.abs(AC[2]) < tol,  # AC on S=0 plane
                np.abs(PC[2]) < tol,  # PC on S=0 plane
                np.abs(AC[1] + PC[1]) < tol,  # MCP origin
                AC[1] > PC[1],  # AC anterior of PC
                np.abs(IH[0]) < tol,  # IH on R=0 plane
                IH[2] > 0,  # IH superior to AC-PC
            )
        ):
            # One or more alignment conditions failed
            aligned = False
        return aligned

    def lockAllControlPoints(self, markupsNode):
        for cpIdx in range(markupsNode.GetNumberOfControlPoints()):
            markupsNode.SetNthControlPointLocked(cpIdx, True)

    def unlockAllControlPoints(self, markupsNode):
        for cpIdx in range(markupsNode.GetNumberOfControlPoints()):
            markupsNode.SetNthControlPointLocked(cpIdx, False)

    def initializeThalNucMarkups(self, markupsNode):
        """Initialize thalamic nuclei markups node using AC-PC standardized
        coordinates. Pulvinar landmarks are named but unplaced.
        """
        markupsNode.RemoveAllControlPoints()
        # based on Dom's refs (no longer used, but leaving here for reference)
        # ANT_R = (3.8 + 5.85) / 2  # +4.82
        # ANT_A = (2.1 + 6.35) / 2  # 4.225
        # ANT_S = (6.2 + 10.1) / 2  # +8.15
        # refCoords = {
        #    "LCM": (-9.0, -4.5, 1.0),
        #    "RCM": (9.0, -4.5, 1.0),
        #    "LANT": (-ANT_R, ANT_A, ANT_S),
        #    "RANT": (ANT_R, ANT_A, ANT_S),
        #    "LPUL": None,
        #    "RPUL": None,
        # }
        # Goldstein coords
        defaultCoords = {
            "LCM": (-8.0, -10.0, 1.0),
            "RCM": (8.0, -10.0, 1.0),
            "LANT": (-5.0, 2.0, 10.0),
            "RANT": (5.0, 2.0, 10.0),
            "LPUL": (-10.0, -14.0, 0.0),
            "RPUL": (10.0, -14.0, 0.0),
        }
        markupsFromDict(defaultCoords, markupsNode)

    def hardenAllTransforms(self):
        """Harden all soft transforms on image, model, and markups nodes.
        This simplifies the scene and prepares for application of
        scene-wide AC-PC transform.  If we don't do this, then it
        is much harder to allow adjustments to AC-PC-IH points and
        recalculation of the transform.
        """
        nodesToHarden = self.gatherNodesToHarden()
        for node in nodesToHarden:
            logging.debug(f"Hardening pre-existing Transform on {node.GetName()}")
            node.HardenTransform()

    def gatherNodesToHarden(self):
        scene = slicer.mrmlScene
        imageNodes = slicer.util.getNodesByClass("vtkMRMLScalarVolumeNode", scene)
        # Apparently label nodes come with image nodes
        # labelNodes = slicer.util.getNodesByClass("vtkMRMLLabelMapVolumeNode", scene)
        modelNodes = slicer.util.getNodesByClass("vtkMRMLModelNode", scene)
        markupsNodes = slicer.util.getNodesByClass("vtkMRMLMarkupsNode", scene)
        # note, this gets all types of markups nodes ^^
        nodesToHarden = []
        nodesToHarden.extend(imageNodes)
        # nodesToHarden.extend(labelNodes)
        nodesToHarden.extend(modelNodes)
        nodesToHarden.extend(markupsNodes)
        # We need to remove hidden nodes from the list before passing it on
        nodesToHarden = [
            node for node in nodesToHarden if node.GetHideFromEditors() == 0
        ]
        return nodesToHarden

    def applyTransformToAll(self, transformNode):
        """Apply the supplied transform to all image, labelmap, model,
        and markups nodes, and harden it.
        """
        nodes = self.gatherNodesToHarden()
        for node in nodes:
            logging.debug(f"Adding AC-PC transform to {node.GetName()}")
            node.SetAndObserveTransformNodeID(transformNode.GetID())
            node.HardenTransform()

    def reorientSlices(self):
        """Orient the red, yellow, and green slice views to axial,
        sagittal, and coronal, respecively
        """
        slicer.util.getNode("vtkMRMLSliceNodeRed").SetOrientation("Axial")
        slicer.util.getNode("vtkMRMLSliceNodeYellow").SetOrientation("Sagittal")
        slicer.util.getNode("vtkMRMLSliceNodeGreen").SetOrientation("Coronal")

    def jumpToNextPoint(self, nucleiMarkup, lockCurrent=True):
        maxIdx = nucleiMarkup.GetNumberOfControlPoints() - 1
        if self._currentPointIdx is None:
            nextIdx = 0
        else:
            nextIdx = self._currentPointIdx + 1
        if nextIdx > maxIdx:
            nextIdx = 0
        if lockCurrent and (self._currentPointIdx is not None):
            nucleiMarkup.SetNthControlPointLocked(self._currentPointIdx, True)
            nucleiMarkup.SetNthControlPointSelected(self._currentPointIdx, 1)
        self.jumpToPointIdx(nextIdx, nucleiMarkup)

    def jumpToPreviousPoint(self, nucleiMarkup, lockCurrent=True):
        maxIdx = nucleiMarkup.GetNumberOfControlPoints() - 1
        if self._currentPointIdx is None:
            prevIdx = maxIdx
        else:
            prevIdx = self._currentPointIdx - 1
        if prevIdx < 0:
            prevIdx = maxIdx
        if lockCurrent and (self._currentPointIdx is not None):
            nucleiMarkup.SetNthControlPointLocked(self._currentPointIdx, True)
        self.jumpToPointIdx(prevIdx, nucleiMarkup)

    def jumpToPointIdx(self, idx, markupsNode):
        """Jumps all slicer to the idx control point of the given markups node.
        If the point is not placed, instead of jumping to it, it is selected
        and we switch in to markups point placement mode to place the point.
        """
        if idx < 0 or idx > (markupsNode.GetNumberOfControlPoints() - 1):
            raise Exception(
                f"Illegal control point index {idx} for markups node named {markupsNode.GetName()}"
            )
        # Unlock the point so it could be dragged
        markupsNode.SetNthControlPointLocked(idx, False)
        markupsNode.SetNthControlPointSelected(idx, 0)
        # Check if the point position is undefined
        status = markupsNode.GetNthControlPointPositionStatus(idx)
        if status == slicer.vtkMRMLMarkupsNode.PositionUndefined:
            # Don't use the position, it's meaningless, instead switch
            # to placement mode to place this point
            markupsNode.SetControlPointPlacementStartIndex(idx)
            placeModePersistence = 0  # not persistent
            slicer.modules.markups.logic().StartPlaceMode(placeModePersistence)
        else:
            # Get the position and jump to it
            pos = markupsNode.GetNthControlPointPositionWorld(idx)
            # Jump all slices to this point (currently offset, not centered)
            self.jumpToPosition(pos)
        # Update current point index
        self._currentPointIdx = idx

    def jumpToPosition(self, pos, centered=False):
        """Jump all slices to postion given.  Slice views are
        centered if centered=True, offset otherwise (default).
        """
        jumpMode = (
            slicer.vtkMRMLSliceNode.CenteredJumpSlice
            if centered
            else slicer.vtkMRMLSliceNode.OffsetJumpSlice
        )
        slicer.vtkMRMLSliceNode.JumpAllSlices(slicer.mrmlScene, *pos, jumpMode)

    def save(self, acpcMarkup, nucleiMarkup, netACPCTransformNode):
        """Save information from these to files.  Also make a table node
        and save as CSV.  Open dialog to choose folder to save to, but
        have sensible default.
        """
        from pathlib import Path
        from slicer.util import saveNode, arrayFromMarkupsControlPoints

        subFolderName = "DirectTargetingData"
        qtParent = None
        startDir = slicer.mrmlScene.GetRootDirectory()
        if startDir == slicer.app.defaultScenePath:
            # Choose directory, default scene path isn't right!
            caption = "Select Existing Folder to Save Results Under..."
            chosenFolder = qt.QFileDialog.getExistingDirectory(
                qtParent, caption, startDir
            )
        else:
            chosenFolder = startDir
        saveDir = Path(chosenFolder, subFolderName)
        # Create directory if missing
        saveDir.mkdir(parents=True, exist_ok=True)
        # Save
        # NOTE: changed so that file names are forced (no multiple versions for repetitions)
        suffix = ""
        testName = Path(saveDir, f"thalNucleiPoints{suffix}.mrk.json")
        # counter = 1
        # while testName.exists():
        #    suffix = f"_{counter}"
        #    testName = Path(saveDir, f"thalNucleiPoints{suffix}.mrk.json")
        #    counter = counter + 1

        acpcPointsFilePath = Path(saveDir, f"acpcPoints{suffix}.mrk.json")
        nucleiFileName = Path(saveDir, f"thalNucleiPoints{suffix}.mrk.json")
        transformFileName = Path(saveDir, f"ACPC_TransformNode{suffix}.tfm")

        saveNode(acpcMarkup, filename=str(acpcPointsFilePath))
        logging.info(f"Saved to {acpcPointsFilePath}")
        saveNode(nucleiMarkup, filename=str(nucleiFileName))
        logging.info(f"Saved to {nucleiFileName}")
        saveNode(netACPCTransformNode, filename=str(transformFileName))
        logging.info(f"Saved to {transformFileName}")
        # Make a table node?
        # Columns are Label, R, A, S; rows are AC, PC, IH, LANT, RANT
        acpc_arr = arrayFromMarkupsControlPoints(acpcMarkup)
        acpc_labels = [
            acpcMarkup.GetNthControlPointLabel(idx)
            for idx in range(acpcMarkup.GetNumberOfControlPoints())
        ]
        nuclei_arr = arrayFromMarkupsControlPoints(nucleiMarkup)
        nuclei_labels = [
            nucleiMarkup.GetNthControlPointLabel(idx)
            for idx in range(nucleiMarkup.GetNumberOfControlPoints())
        ]
        # Actually should really add a check here for unplaced points on nuclei markup
        labelCol = vtk.vtkStringArray()
        labelCol.SetName("Label")
        RCol = vtk.vtkFloatArray()
        RCol.SetName("R")
        ACol = vtk.vtkFloatArray()
        ACol.SetName("A")
        SCol = vtk.vtkFloatArray()
        SCol.SetName("S")
        for label, pt in zip(acpc_labels, acpc_arr):
            labelCol.InsertNextValue(label)
            RCol.InsertNextValue(pt[0])
            ACol.InsertNextValue(pt[1])
            SCol.InsertNextValue(pt[2])
        for label, pt in zip(nuclei_labels, nuclei_arr):
            labelCol.InsertNextValue(label)
            RCol.InsertNextValue(pt[0])
            ACol.InsertNextValue(pt[1])
            SCol.InsertNextValue(pt[2])
        # Make table node
        tableNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLTableNode", "ACPC_Thal_Points_Table"
        )
        tableNode.AddColumn(labelCol)
        tableNode.AddColumn(RCol)
        tableNode.AddColumn(ACol)
        tableNode.AddColumn(SCol)
        # Save table
        tablePath = Path(saveDir, f"ACPC_Thal_Points_Table{suffix}.csv")
        saveNode(tableNode, str(tablePath))
        logging.info(f"Saved to {tablePath}")

    def load(
        self,
        loadDir=None,
        currentTransformNode=None,
        currentACPCpoints=None,
        currentThalNucPoints=None,
    ):
        """So it is possible to adjust saved positions, need to be able to load.
        Also means that we need to time-stamp outputs, so that downstream calculations
        can be re-done when needed.
        """

        from pathlib import Path
        from slicer.util import (
            errorDisplay,
            loadTable,
            arrayFromMarkupsControlPoints,
            arrayFromTransformMatrix,
            loadMarkups,
            loadTransform,
        )

        scene = slicer.mrmlScene
        if loadDir is None:
            loadDir = Path(scene.GetRootDirectory(), "DirectTargetingData")
        okToLoad, msg = self.checkCanLoad(loadDir)
        if not okToLoad:
            errorDisplay(msg)
            raise Exception(msg)
        # Ok to proceed with loading,
        ### Restore original positions by inverting existing transformation
        if currentTransformNode:
            self.hardenAllTransforms()  # Shouldn't be necessary, but also shouldn't hurt
            currentTransformNode.Inverse()
            self.applyTransformToAll(currentTransformNode)
        # Remove current points nodes (to be replaced by the loaded ones)
        for node in [currentACPCpoints, currentThalNucPoints]:
            scene.RemoveNode(node)
        ### Load saved net ACPC transform
        tformPath = Path(loadDir, "ACPC_TransformNode.tfm")
        tempTForm = loadTransform(str(tformPath))
        ### Apply saved net transform to everything
        self.applyTransformToAll(tempTForm)
        ### Load saved points
        suffix = ""
        acpcPointsPath = Path(loadDir, f"acpcPoints{suffix}.mrk.json")
        acpcMarkup = loadMarkups(str(acpcPointsPath))
        thalNucleiPointsPath = Path(loadDir, f"thalNucleiPoints{suffix}.mrk.json")
        nucleiMarkup = loadMarkups(str(thalNucleiPointsPath))
        # Load Table Node also?
        tableFilePath = Path(loadDir, f"ACPC_Thal_Points_Table{suffix}.csv")
        tableNode = loadTable(str(tableFilePath))
        # Get Transform matrix
        netTransformMatrix = arrayFromTransformMatrix(tempTForm)

        return acpcMarkup, nucleiMarkup, netTransformMatrix

    def checkCanLoad(self, loadDir) -> bool:
        """Before loading, check that it seems like we can load"""
        from pathlib import Path

        scene = slicer.mrmlScene
        sceneRootDir = scene.GetRootDirectory()
        if sceneRootDir == slicer.app.defaultScenePath:
            return False
        if loadDir is None:
            loadDir = Path(scene.GetRootDir(), "DirectTargetingData")
        suffix = ""
        # Table file
        tableFilePath = Path(loadDir, f"ACPC_Thal_Points_Table{suffix}.csv")
        acpcPointsPath = Path(loadDir, f"acpcPoints{suffix}.mrk.json")
        thalNucleiPointsPath = Path(loadDir, f"thalNucleiPoints{suffix}.mrk.json")
        # Check file existence
        if not tableFilePath.exists():
            return False, f"No saved data available in {loadDir}"
        if not acpcPointsPath.exists():
            return False, "no acpcPoints.mrk.json file found"
        if not thalNucleiPointsPath.exists():
            return False, "no thalNucleiPoints.mrk.json file found"
        # Everything seems to be OK
        return True, ""

    def setSliceIntersectionVisibility(self, visiblityFlag: bool = True):
        """Turn on/off slice intersection visibility"""
        visInt = 1 if visiblityFlag else 0
        sliceDisplayNodes = slicer.util.getNodesByClass("vtkMRMLSliceDisplayNode")
        for sliceDisplayNode in sliceDisplayNodes:
            sliceDisplayNode.SetIntersectingSlicesVisibility(visInt)
        # Force visual update (see https://github.com/Slicer/Slicer/issues/6338)
        sliceNodes = slicer.util.getNodesByClass("vtkMRMLSliceNode")
        for sliceNode in sliceNodes:
            sliceNode.Modified()


#
# ACPCTransformTest
#
class ACPCTransformTest(ScriptedLoadableModuleTest):
    def setUp(self):
        slicer.mrmlScene.Clear(0)

    def runTest(self):
        self.setUp()
        self.test_ACPCTransform_Calculation_Interactive()

    def test_ACPCTransform_Calculation_Interactive(self):
        self.delayDisplay(
            "Starting AC-PC Transform test with simulated interactive placement"
        )
        markupsNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLMarkupsFiducialNode", "TestFiducials"
        )

        # Simulate ensureMarkupsNodeIsSetup (using the corrected method)
        pointLabels = ["AC", "PC", "IH"]
        for label_text in pointLabels:
            newPointIndex = markupsNode.AddControlPoint([0.0, 0.0, 0.0], label_text)
            markupsNode.UnsetNthControlPointPosition(
                newPointIndex
            )  # Corrected line for test

        ac_coords = [0, 10, 0]
        pc_coords = [0, -10, 0]
        ih_coords = [0, 0, 10]

        # Simulate point placement by user
        markupsNode.SetNthControlPointPositionWorld(0, ac_coords)
        markupsNode.SetNthControlPointPositionStatus(
            0, slicer.vtkMRMLMarkupsNode.PositionDefined
        )

        markupsNode.SetNthControlPointPositionWorld(1, pc_coords)
        markupsNode.SetNthControlPointPositionStatus(
            1, slicer.vtkMRMLMarkupsNode.PositionDefined
        )

        markupsNode.SetNthControlPointPositionWorld(2, ih_coords)
        markupsNode.SetNthControlPointPositionStatus(
            2, slicer.vtkMRMLMarkupsNode.PositionDefined
        )

        outputTransformNode = slicer.mrmlScene.AddNewNodeByClass(
            "vtkMRMLTransformNode", "TestACPCTransform"
        )
        logic = ACPCTransformLogic()
        success = logic.calculateACPCTransform(markupsNode, outputTransformNode)
        self.assertTrue(success)

        matrix_vtk = vtk.vtkMatrix4x4()
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)
        expected_matrix_elements = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_matrix_elements[r][c],
                    places=5,
                )

        self.delayDisplay("Setting up complex case for test")
        markupsNode.SetNthControlPointPositionWorld(0, [1, 11, 1])
        markupsNode.SetNthControlPointPositionWorld(1, [1, -9, 1])
        markupsNode.SetNthControlPointPositionWorld(2, [1, 1, 11])
        for i in range(3):
            markupsNode.SetNthControlPointPositionStatus(
                i, slicer.vtkMRMLMarkupsNode.PositionDefined
            )

        success = logic.calculateACPCTransform(markupsNode, outputTransformNode)
        self.assertTrue(success)
        outputTransformNode.GetMatrixTransformToParent(matrix_vtk)
        expected_elements_complex = [
            [1, 0, 0, -1],
            [0, 1, 0, -1],
            [0, 0, 1, -1],
            [0, 0, 0, 1],
        ]
        for r in range(4):
            for c in range(4):
                self.assertAlmostEqual(
                    matrix_vtk.GetElement(r, c),
                    expected_elements_complex[r][c],
                    places=5,
                    msg=f"Elem ({r},{c})",
                )
        self.delayDisplay("AC-PC Transform test passed")


####### Helper Functions #######
def markupsFromDict(coordDict, outputMarkupsNode):
    """Create markups control points from dict where
    point labels are the keys and coords are the values.
    A None value triggers creation of a point with given
    label but unset (undefined) position.
    """
    outputMarkupsNode.RemoveAllControlPoints()
    for label, coord in coordDict.items():
        cpIdx = outputMarkupsNode.AddControlPoint(0, 0, 0, label)
        if coord is None:
            # unset the postion
            outputMarkupsNode.UnsetNthControlPointPosition(cpIdx)
        else:
            outputMarkupsNode.SetNthControlPointPositionWorld(cpIdx, *coord)
